/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { Subject } from 'rxjs';
import { MatClockView } from './clock-view';
import { MAT_DATE_FORMATS } from './core/index';
import { DateAdapter } from './core/index';
import { matDatepickerAnimations } from './datepicker-animations';
import { createMissingDateImplError } from './datepicker-errors';
import { MatDatepickerIntl } from './datepicker-intl';
import { MatMonthView } from './month-view';
import { MatYearView } from './year-view';
import { MatYearsView } from './years-view';
/**
 * A calendar that is used as part of the datepicker.
 * \@docs-private
 * @template D
 */
export class MatCalendar {
    /**
     * @param {?} _intl
     * @param {?} _dateAdapter
     * @param {?} _dateFormats
     * @param {?} _changeDetectorRef
     */
    constructor(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
        this._intl = _intl;
        this._dateAdapter = _dateAdapter;
        this._dateFormats = _dateFormats;
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * Used for scheduling that focus should be moved to the active cell on the next tick.
         * We need to schedule it, rather than do it immediately, because we have to wait
         * for Angular to re-evaluate the view children.
         */
        this._moveFocusOnNextTick = false;
        /** The type of value handled by the calendar. */
        this.type = 'date';
        /** Which view the calendar should be started in. */
        this.startView = 'month';
        /** Clock interval */
        this.clockStep = 1;
        /** Clock hour format */
        this.twelveHour = false;
        /** Emits when the currently selected date changes. */
        this.selectedChange = new EventEmitter();
        /** Emits when any date is selected. */
        this._userSelection = new EventEmitter();
        /** Date filter for the month and year views. */
        this._dateFilterForViews = (date, unit = 'minute') => {
            return (!!date &&
                (!this.dateFilter || this.dateFilter(date)) &&
                (!this.minDate || this._dateAdapter.compareDate(date, this.minDate, unit) >= 0) &&
                (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate, unit) <= 0));
        };
        /**
         * Emits whenever there is a state change that the header may need to respond to.
         */
        this.stateChanges = new Subject();
        /** Whether the calendar is in hour view. */
        this._hourView = true;
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
        if (!this._dateFormats) {
            throw createMissingDateImplError('MAT_DATE_FORMATS');
        }
        this._intlChanges = _intl.changes.subscribe(() => {
            _changeDetectorRef.markForCheck();
            this.stateChanges.next();
        });
    }
    /**
     * A date representing the period (month or year) to start the calendar in.
     * @return {?}
     */
    get startAt() {
        return this._startAt;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set startAt(value) {
        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    }
    /**
     * The currently selected date.
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        if (this._selected) {
            this.activeDate = this._selected;
        }
    }
    /**
     * The minimum selectable date.
     * @return {?}
     */
    get minDate() {
        return this._minDate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minDate(value) {
        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    }
    /**
     * The maximum selectable date.
     * @return {?}
     */
    get maxDate() {
        return this._maxDate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxDate(value) {
        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    }
    /**
     * The current active date. This determines which time period is shown and which date is
     * highlighted when using keyboard navigation.
     * @return {?}
     */
    get activeDate() {
        return this._clampedActiveDate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set activeDate(value) {
        /** @type {?} */
        const oldActiveDate = this._clampedActiveDate;
        this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
        this._isAm = this._dateAdapter.getHours(this._clampedActiveDate) < 12;
        /** @type {?} */
        const unit = this.view === 'year' ? 'year' : 'month';
        /** @type {?} */
        const diff = this._dateAdapter.compareDate(oldActiveDate, this._clampedActiveDate, unit);
        if (diff) {
            this._animationDir = diff > 0 ? 'left' : 'right';
        }
        // update the labels
        /** @type {?} */
        const day = this._dateAdapter.getDayOfWeek(this.activeDate);
        /** @type {?} */
        let hours = this._dateAdapter.getHours(this.activeDate);
        if (this.twelveHour) {
            hours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
        }
        /** @type {?} */
        const minutes = this._dateAdapter.getMinutes(this.activeDate);
        switch (this.view) {
            case 'year':
                this._periodButtonText = this._dateAdapter.getYearName(this.activeDate);
                break;
            default:
                this._periodButtonText = this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthYearLabel);
        }
        this._yearButtonText = this._dateAdapter.getYear(this.activeDate).toString();
        this._monthdayButtonText = this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthDayLabel);
        this._dayButtonText = this._dateAdapter.getDayOfWeekNames('short')[day];
        this._hourButtonText = hours.toString();
        this._minuteButtonText = ('00' + minutes).slice(-2);
        this.stateChanges.next();
    }
    /**
     * Whether the calendar is in month view.
     * @return {?}
     */
    get currentView() {
        return this._currentView;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set currentView(value) {
        this._currentView = value;
        this._moveFocusOnNextTick = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.activeDate = this.startAt || this._dateAdapter.today();
        this.changeView(this.startView, false);
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this._moveFocusOnNextTick) {
            this._moveFocusOnNextTick = false;
            this.focusActiveCell();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._intlChanges.unsubscribe();
        this.stateChanges.complete();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this._hasTime = this.type.indexOf('time') >= 0;
        /** @type {?} */
        const change = changes.selected || changes.minDate || changes.maxDate || changes.dateFilter;
        if (change && !change.firstChange) {
            /** @type {?} */
            const view = this._getCurrentViewComponent();
            if (view) {
                // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                this._changeDetectorRef.detectChanges();
                view._init();
            }
        }
        this.stateChanges.next();
    }
    /**
     * @param {?} view
     * @param {?=} focus
     * @return {?}
     */
    changeView(view, focus = true) {
        switch (view) {
            case 'year':
                this._periodButtonText = this._dateAdapter.getYearName(this.activeDate);
                this._periodButtonLabel = this._intl.switchToYearsViewLabel;
                this._nextButtonLabel = this._intl.nextYearLabel;
                this._prevButtonLabel = this._intl.prevYearLabel;
                break;
            case 'month':
                this._periodButtonText = this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthYearLabel);
                this._periodButtonLabel = this._intl.switchToYearViewLabel;
                this._nextButtonLabel = this._intl.nextMonthLabel;
                this._prevButtonLabel = this._intl.prevMonthLabel;
        }
        this.view = view;
        if (focus) {
            this._moveFocusOnNextTick = true;
        }
    }
    /**
     * @return {?}
     */
    focusActiveCell() {
        this._getCurrentViewComponent()._focusActiveCell();
    }
    /**
     * @return {?}
     */
    _submitClicked() {
        this.selectedChange.emit(this.activeDate);
        this._userSelection.emit();
    }
    /**
     * @return {?}
     */
    _cancelClicked() {
        this._userSelection.emit();
    }
    /**
     * Handles date selection in the clock view.
     * @param {?} date
     * @return {?}
     */
    _timeChanged(date) {
        this.selected = date;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    _timeSelected(date) {
        // if (this.autoOk && this.type === 'time') {
        //   this.selectedChange.emit(date);
        //   this._userSelection.emit();
        // }
        this.selected = date;
    }
    /**
     * Handles date selection in the month view.
     * @param {?} date
     * @return {?}
     */
    _dateSelected(date) {
        this.selected = date;
        if (this._hasTime) {
            this.changeView('clock');
        }
    }
    /**
     * Handles month selection in the year view.
     * @param {?} month
     * @return {?}
     */
    _monthSelected(month) {
        this.selected = month;
        this.changeView('month');
    }
    /**
     * @param {?} year
     * @return {?}
     */
    _yearSelected(year) {
        this.selected = year;
        this.changeView('year');
    }
    /**
     * Handles user clicks on the period label.
     * @return {?}
     */
    _currentPeriodClicked() {
        this.changeView(this.view === 'month' ? 'year' : 'years');
    }
    /**
     * Handles user clicks on the previous button.
     * @return {?}
     */
    _previousClicked() {
        this._navCalendar(-1);
    }
    /**
     * Handles user clicks on the next button.
     * @return {?}
     */
    _nextClicked() {
        this._navCalendar(1);
    }
    /**
     * Handles user clicks on the time labels.
     * @return {?}
     */
    _showHourView() {
        if (this._hasTime) {
            this._hourView = true;
            this.changeView('clock');
        }
    }
    /**
     * @return {?}
     */
    _showMinuteView() {
        this._hourView = false;
        this.changeView('clock');
    }
    /**
     * @param {?} am
     * @return {?}
     */
    _toggleAmPm(am) {
        if (this._isAm !== am) {
            /** @type {?} */
            const date = this._dateAdapter.addCalendarHours(this.activeDate, this._isAm ? 12 : -12);
            if (this._dateFilterForViews(date, 'minute')) {
                this.selected = date;
            }
        }
    }
    /**
     * Whether the previous period button is enabled.
     * @return {?}
     */
    _previousEnabled() {
        if (!this.minDate) {
            return true;
        }
        return !this.minDate || !this._isSameView(this.activeDate, this.minDate);
    }
    /**
     * Whether the next period button is enabled.
     * @return {?}
     */
    _nextEnabled() {
        return !this.maxDate || !this._isSameView(this.activeDate, this.maxDate);
    }
    /**
     * Handles calendar diffs.
     * @param {?} diff
     * @return {?}
     */
    _navCalendar(diff) {
        switch (this.view) {
            case 'year':
                this.activeDate = this._dateAdapter.addCalendarYears(this.activeDate, diff);
                break;
            case 'month':
                this.activeDate = this._dateAdapter.addCalendarMonths(this.activeDate, diff);
                break;
            case 'clock':
                this.activeDate = this._hourView
                    ? this._dateAdapter.addCalendarHours(this.activeDate, diff)
                    : this._dateAdapter.addCalendarMinutes(this.activeDate, diff);
                break;
        }
    }
    /**
     * Whether the two dates represent the same view in the current view mode (month or year).
     * @param {?} date1
     * @param {?} date2
     * @return {?}
     */
    _isSameView(date1, date2) {
        switch (this.view) {
            case 'year':
                return this._dateAdapter.getYear(date1) === this._dateAdapter.getYear(date2);
            case 'month':
                /** @type {?} */
                const monthYear = this._dateFormats.display.monthYearLabel;
                return (this._dateAdapter.format(date1, monthYear) === this._dateAdapter.format(date2, monthYear));
            case 'clock':
            default:
                /** @type {?} */
                const hourMinute = this._dateFormats.display.timeLabel;
                return (this._dateAdapter.format(date1, hourMinute) ===
                    this._dateAdapter.format(date2, hourMinute));
        }
    }
    /**
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    _getValidDateOrNull(obj) {
        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;
    }
    /**
     * Returns the component instance that corresponds to the current calendar view.
     * @return {?}
     */
    _getCurrentViewComponent() {
        return this.clockView || this.monthView || this.yearView || this.yearsView;
    }
}
MatCalendar.decorators = [
    { type: Component, args: [{
                selector: 'mat-calendar',
                template: `<div [class]="'mat-calendar-header mat-calendar-type-' + type">

  <div class="mat-calendar-header-date">
    <button class="mat-calendar-header-date-year mat-calendar-control"
    [class.mat-calendar-control-active]="view == 'years'"
    [@controlActive]="view == 'years' ? 'active' : ''"
    [attr.aria-label]="_intl.switchToYearViewLabel"
    (click)="changeView('years')">
      {{ _yearButtonText }}
    </button>

    <button class="mat-calendar-header-date-month mat-calendar-control"
    [class.mat-calendar-control-active]="view == 'month' || view == 'year'"
    [@controlActive]="view == 'month' || view == 'year' ? 'active' : ''"
    [attr.aria-label]="_intl.switchToMonthViewLabel"
    (click)="changeView('month')">
      <span class="mat-calendar-header-date-dayname">{{ _dayButtonText }}, </span>
      <span class="mat-calendar-header-date-monthday">{{ _monthdayButtonText }}</span>
    </button>
  </div>

  <div class="mat-calendar-header-time">
    <div class="mat-calendar-header-time-hour">
      <button class="mat-calendar-control"
      [class.mat-calendar-control-active]="view == 'clock' && _hourView"
      [@controlActive]="view == 'clock' && _hourView ? 'active' : ''"
      [attr.aria-label]="_intl.switchToHourViewLabel"
      (click)="_showHourView()">
        {{ _hourButtonText }}
      </button>
      <span>:</span>
      <button class="mat-calendar-control"
      [class.mat-calendar-control-active]="view == 'clock' && !_hourView"
      [@controlActive]="view == 'clock' && !_hourView ? 'active' : ''"
      [attr.aria-label]="_intl.switchToMinuteViewLabel"
      (click)="_showMinuteView()">
        {{ _minuteButtonText }}
      </button>
    </div>
    <div class="mat-calendar-header-time-ampm" *ngIf="twelveHour">
      <button class="mat-calendar-control"
      [class.mat-calendar-control-active]="_isAm"
      [@controlActive]="_isAm ? 'active' : ''"
      [attr.aria-label]="_intl.setToAMLabel"
      (click)="_toggleAmPm(true)">
        AM
      </button>
      <button class="mat-calendar-control"
      [class.mat-calendar-control-active]="!_isAm"
      [@controlActive]="!_isAm ? 'active' : ''"
      [attr.aria-label]="_intl.setToPMLabel"
      (click)="_toggleAmPm(false)">
        PM
      </button>
    </div>
  </div>
</div>

<div [class]="'mat-calendar-content mat-calendar-view-' + view">

  <div class="mat-calendar-heading" *ngIf="view === 'month' || view === 'year'">
    <button mat-icon-button class="mat-calendar-previous-button"
      (click)="_previousClicked()" [attr.disabled]="!_previousEnabled() ? '' : null"
      [attr.aria-label]="_prevButtonLabel">
    </button>

    <button class="mat-calendar-heading-period mat-calendar-control mat-calendar-control-active"
    [@slideCalendar]="_animationDir" (@slideCalendar.done)="_animationDir = ''"
    (click)="_currentPeriodClicked()"
    [attr.aria-label]="_periodButtonLabel">
      <strong>{{ _periodButtonText }}</strong>
    </button>

    <button mat-icon-button class="mat-calendar-next-button"
      (click)="_nextClicked()" [attr.disabled]="!_nextEnabled() ? '' : null"
      [attr.aria-label]="_nextButtonLabel">
    </button>
  </div>

  <div class="mat-calendar-main" [ngSwitch]="view" cdkMonitorSubtreeFocus tabindex="-1">

    <mat-clock-view
      *ngSwitchCase="'clock'"
      [(activeDate)]="activeDate"
      [selected]="selected"
      [dateFilter]="_dateFilterForViews"
      [clockStep]="clockStep"
      [twelveHour]="twelveHour"
      [hourView]="_hourView"
      (selectedTime)="_timeSelected($event)"
      (selectedChange)="_timeChanged($event)"
      (changeView)="_hourView = !_hourView">
    </mat-clock-view>

    <mat-month-view
      *ngSwitchCase="'month'"
      [(activeDate)]="activeDate"
      [selected]="selected"
      [dateFilter]="_dateFilterForViews"
      [maxDate]="maxDate"
      [minDate]="minDate"
      [animationDir]="_animationDir"
      (selectedChange)="_dateSelected($event)"
      (_userSelection)="_showHourView()">
    </mat-month-view>

    <mat-year-view
      *ngSwitchCase="'year'"
      [(activeDate)]="activeDate"
      [selected]="selected"
      [dateFilter]="_dateFilterForViews"
      [maxDate]="maxDate"
      [minDate]="minDate"
      [animationDir]="_animationDir"
      (selectedChange)="_monthSelected($event)">
    </mat-year-view>

    <mat-years-view
      *ngSwitchCase="'years'"
      [(activeDate)]="activeDate"
      [selected]="selected"
      [dateFilter]="_dateFilterForViews"
      [maxDate]="maxDate"
      [minDate]="minDate"
      (selectedChange)="_yearSelected($event)">
    </mat-years-view>
  </div>

  <div class="mat-calendar-footer">
    <button mat-button
    (click)="_cancelClicked()"
    [attr.aria-label]="_intl.buttonCancelLabel">
      {{ _intl.buttonCancelText }}
    </button>

    <button mat-button
    (click)="_submitClicked()"
    [attr.aria-label]="_intl.buttonSubmitLabel">
      {{ _intl.buttonSubmitText }}
    </button>
  </div>
</div>
`,
                // styleUrls: ['calendar.css'],
                host: {
                    class: 'mat-calendar'
                },
                animations: [matDatepickerAnimations.controlActive, matDatepickerAnimations.slideCalendar],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            },] },
];
MatCalendar.ctorParameters = () => [
    { type: MatDatepickerIntl },
    { type: DateAdapter, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] }] },
    { type: ChangeDetectorRef }
];
MatCalendar.propDecorators = {
    startAt: [{ type: Input }],
    type: [{ type: Input }],
    startView: [{ type: Input }],
    selected: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    dateFilter: [{ type: Input }],
    clockStep: [{ type: Input }],
    twelveHour: [{ type: Input }],
    selectedChange: [{ type: Output }],
    _userSelection: [{ type: Output }],
    clockView: [{ type: ViewChild, args: [MatClockView,] }],
    monthView: [{ type: ViewChild, args: [MatMonthView,] }],
    yearView: [{ type: ViewChild, args: [MatYearView,] }],
    yearsView: [{ type: ViewChild, args: [MatYearsView,] }]
};
if (false) {
    /** @type {?} */
    MatCalendar.prototype._intlChanges;
    /**
     * Used for scheduling that focus should be moved to the active cell on the next tick.
     * We need to schedule it, rather than do it immediately, because we have to wait
     * for Angular to re-evaluate the view children.
     * @type {?}
     */
    MatCalendar.prototype._moveFocusOnNextTick;
    /** @type {?} */
    MatCalendar.prototype._startAt;
    /**
     * The type of value handled by the calendar.
     * @type {?}
     */
    MatCalendar.prototype.type;
    /**
     * Which view the calendar should be started in.
     * @type {?}
     */
    MatCalendar.prototype.startView;
    /**
     * Current calendar view
     * @type {?}
     */
    MatCalendar.prototype.view;
    /** @type {?} */
    MatCalendar.prototype._selected;
    /** @type {?} */
    MatCalendar.prototype._minDate;
    /** @type {?} */
    MatCalendar.prototype._maxDate;
    /**
     * A function used to filter which dates are selectable.
     * @type {?}
     */
    MatCalendar.prototype.dateFilter;
    /**
     * Clock interval
     * @type {?}
     */
    MatCalendar.prototype.clockStep;
    /**
     * Clock hour format
     * @type {?}
     */
    MatCalendar.prototype.twelveHour;
    /**
     * Emits when the currently selected date changes.
     * @type {?}
     */
    MatCalendar.prototype.selectedChange;
    /**
     * Emits when any date is selected.
     * @type {?}
     */
    MatCalendar.prototype._userSelection;
    /**
     * Reference to the current clock view component.
     * @type {?}
     */
    MatCalendar.prototype.clockView;
    /**
     * Reference to the current month view component.
     * @type {?}
     */
    MatCalendar.prototype.monthView;
    /**
     * Reference to the current year view component.
     * @type {?}
     */
    MatCalendar.prototype.yearView;
    /**
     * Reference to the current years view component.
     * @type {?}
     */
    MatCalendar.prototype.yearsView;
    /**
     * Date filter for the month and year views.
     * @type {?}
     */
    MatCalendar.prototype._dateFilterForViews;
    /** @type {?} */
    MatCalendar.prototype._clampedActiveDate;
    /** @type {?} */
    MatCalendar.prototype._currentView;
    /**
     * Emits whenever there is a state change that the header may need to respond to.
     * @type {?}
     */
    MatCalendar.prototype.stateChanges;
    /**
     * Animations handler
     * @type {?}
     */
    MatCalendar.prototype._animationDir;
    /**
     * Whether the active date is AM or not
     * @type {?}
     */
    MatCalendar.prototype._isAm;
    /**
     * Whether the calendar process the time.
     * @type {?}
     */
    MatCalendar.prototype._hasTime;
    /**
     * Whether the calendar is in hour view.
     * @type {?}
     */
    MatCalendar.prototype._hourView;
    /**
     * The label for the calendar header buttons.
     * @type {?}
     */
    MatCalendar.prototype._yearButtonText;
    /** @type {?} */
    MatCalendar.prototype._dayButtonText;
    /** @type {?} */
    MatCalendar.prototype._monthdayButtonText;
    /** @type {?} */
    MatCalendar.prototype._hourButtonText;
    /** @type {?} */
    MatCalendar.prototype._minuteButtonText;
    /**
     * The label for the current calendar view.
     * @type {?}
     */
    MatCalendar.prototype._periodButtonText;
    /** @type {?} */
    MatCalendar.prototype._periodButtonLabel;
    /**
     * The label for the the previous button.
     * @type {?}
     */
    MatCalendar.prototype._prevButtonLabel;
    /**
     * The label for the the next button.
     * @type {?}
     */
    MatCalendar.prototype._nextButtonLabel;
    /** @type {?} */
    MatCalendar.prototype._intl;
    /** @type {?} */
    MatCalendar.prototype._dateAdapter;
    /** @type {?} */
    MatCalendar.prototype._dateFormats;
    /** @type {?} */
    MatCalendar.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY29hY2hjYXJlL2RhdGVwaWNrZXIvIiwic291cmNlcyI6WyJjYWxlbmRhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQVFBLE9BQU8sRUFHTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFHTCxRQUFRLEVBQ1IsTUFBTSxFQUVOLFNBQVMsRUFDVCxpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUM1QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQWtCLE1BQU0sY0FBYyxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDbEUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUM1QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxjQUFjLENBQUM7Ozs7OztBQTRLNUMsTUFBTTs7Ozs7OztJQXFNSixZQUNTLEtBQXdCLEVBQ1gsWUFBNEIsRUFHeEMsWUFBNEIsRUFDNUIsa0JBQXFDO1FBTHRDLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ1gsaUJBQVksR0FBWixZQUFZLENBQWdCO1FBR3hDLGlCQUFZLEdBQVosWUFBWSxDQUFnQjtRQUM1Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBeE0vQzs7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Ozs7SUFHM0IsaUNBQXlEOzs7OztJQUd6RCxnQ0FBdUI7Ozs7O0lBR3ZCLGlDQUE0Qjs7Ozs7SUFHNUIscUNBQWlEOzs7OztJQUdqRCxxQ0FBb0Q7Ozs7O0lBR3BELGdDQUFvRDs7Ozs7SUFHcEQsZ0NBQW9EOzs7OztJQUdwRCwrQkFBaUQ7Ozs7O0lBR2pELGdDQUFvRDs7Ozs7SUFHcEQsMENBT0U7O0lBaURGLHlDQUE4Qjs7SUFVOUIsbUNBQXNDOzs7OztJQUt0QyxtQ0FBbUM7Ozs7O0lBR25DLG9DQUFzQjs7Ozs7SUFHdEIsNEJBQWU7Ozs7O0lBR2YsK0JBQWtCOzs7OztJQUdsQixnQ0FBMEI7Ozs7O0lBRzFCLHNDQUF3Qjs7SUFFeEIscUNBQXVCOztJQUV2QiwwQ0FBNEI7O0lBRTVCLHNDQUF3Qjs7SUFFeEIsd0NBQTBCOzs7OztJQUcxQix3Q0FBMEI7O0lBRTFCLHlDQUEyQjs7Ozs7SUFHM0IsdUNBQXlCOzs7OztJQUd6Qix1Q0FBeUI7O0lBR3ZCLDRCQUErQjs7SUFDL0IsbUNBQWdEOztJQUNoRCxtQ0FFb0M7O0lBQ3BDLHlDQUE2QyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdDaGVja2VkLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVmlld0NoaWxkLFxuICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTWF0Q2xvY2tWaWV3IH0gZnJvbSAnLi9jbG9jay12aWV3JztcbmltcG9ydCB7IE1BVF9EQVRFX0ZPUk1BVFMsIE1hdERhdGVGb3JtYXRzIH0gZnJvbSAnLi9jb3JlL2luZGV4JztcbmltcG9ydCB7IERhdGVBZGFwdGVyIH0gZnJvbSAnLi9jb3JlL2luZGV4JztcbmltcG9ydCB7IG1hdERhdGVwaWNrZXJBbmltYXRpb25zIH0gZnJvbSAnLi9kYXRlcGlja2VyLWFuaW1hdGlvbnMnO1xuaW1wb3J0IHsgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IgfSBmcm9tICcuL2RhdGVwaWNrZXItZXJyb3JzJztcbmltcG9ydCB7IE1hdERhdGVwaWNrZXJJbnRsIH0gZnJvbSAnLi9kYXRlcGlja2VyLWludGwnO1xuaW1wb3J0IHsgTWF0TW9udGhWaWV3IH0gZnJvbSAnLi9tb250aC12aWV3JztcbmltcG9ydCB7IE1hdFllYXJWaWV3IH0gZnJvbSAnLi95ZWFyLXZpZXcnO1xuaW1wb3J0IHsgTWF0WWVhcnNWaWV3IH0gZnJvbSAnLi95ZWFycy12aWV3JztcblxuLyoqXG4gKiBQb3NzaWJsZSB2aWV3cyBmb3IgdGhlIGNhbGVuZGFyLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgdHlwZSBNYXRDYWxlbmRhclZpZXcgPSAnY2xvY2snIHwgJ21vbnRoJyB8ICd5ZWFyJyB8ICd5ZWFycyc7XG5cbi8qKlxuICogUG9zc2libGUgcmV0dXJuIHR5cGVzLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgdHlwZSBNYXRDYWxlbmRhclR5cGUgPSAnZGF0ZScgfCAnZGF0ZXRpbWUnIHwgJ3RpbWUnO1xuXG4vKipcbiAqIEEgY2FsZW5kYXIgdGhhdCBpcyB1c2VkIGFzIHBhcnQgb2YgdGhlIGRhdGVwaWNrZXIuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21hdC1jYWxlbmRhcicsXG4gIHRlbXBsYXRlOiBgPGRpdiBbY2xhc3NdPVwiJ21hdC1jYWxlbmRhci1oZWFkZXIgbWF0LWNhbGVuZGFyLXR5cGUtJyArIHR5cGVcIj5cblxuICA8ZGl2IGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci1kYXRlXCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cIm1hdC1jYWxlbmRhci1oZWFkZXItZGF0ZS15ZWFyIG1hdC1jYWxlbmRhci1jb250cm9sXCJcbiAgICBbY2xhc3MubWF0LWNhbGVuZGFyLWNvbnRyb2wtYWN0aXZlXT1cInZpZXcgPT0gJ3llYXJzJ1wiXG4gICAgW0Bjb250cm9sQWN0aXZlXT1cInZpZXcgPT0gJ3llYXJzJyA/ICdhY3RpdmUnIDogJydcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuc3dpdGNoVG9ZZWFyVmlld0xhYmVsXCJcbiAgICAoY2xpY2spPVwiY2hhbmdlVmlldygneWVhcnMnKVwiPlxuICAgICAge3sgX3llYXJCdXR0b25UZXh0IH19XG4gICAgPC9idXR0b24+XG5cbiAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci1kYXRlLW1vbnRoIG1hdC1jYWxlbmRhci1jb250cm9sXCJcbiAgICBbY2xhc3MubWF0LWNhbGVuZGFyLWNvbnRyb2wtYWN0aXZlXT1cInZpZXcgPT0gJ21vbnRoJyB8fCB2aWV3ID09ICd5ZWFyJ1wiXG4gICAgW0Bjb250cm9sQWN0aXZlXT1cInZpZXcgPT0gJ21vbnRoJyB8fCB2aWV3ID09ICd5ZWFyJyA/ICdhY3RpdmUnIDogJydcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuc3dpdGNoVG9Nb250aFZpZXdMYWJlbFwiXG4gICAgKGNsaWNrKT1cImNoYW5nZVZpZXcoJ21vbnRoJylcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci1kYXRlLWRheW5hbWVcIj57eyBfZGF5QnV0dG9uVGV4dCB9fSwgPC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtYXQtY2FsZW5kYXItaGVhZGVyLWRhdGUtbW9udGhkYXlcIj57eyBfbW9udGhkYXlCdXR0b25UZXh0IH19PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci10aW1lXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1oZWFkZXItdGltZS1ob3VyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWNvbnRyb2xcIlxuICAgICAgW2NsYXNzLm1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZV09XCJ2aWV3ID09ICdjbG9jaycgJiYgX2hvdXJWaWV3XCJcbiAgICAgIFtAY29udHJvbEFjdGl2ZV09XCJ2aWV3ID09ICdjbG9jaycgJiYgX2hvdXJWaWV3ID8gJ2FjdGl2ZScgOiAnJ1wiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIl9pbnRsLnN3aXRjaFRvSG91clZpZXdMYWJlbFwiXG4gICAgICAoY2xpY2spPVwiX3Nob3dIb3VyVmlldygpXCI+XG4gICAgICAgIHt7IF9ob3VyQnV0dG9uVGV4dCB9fVxuICAgICAgPC9idXR0b24+XG4gICAgICA8c3Bhbj46PC9zcGFuPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cIm1hdC1jYWxlbmRhci1jb250cm9sXCJcbiAgICAgIFtjbGFzcy5tYXQtY2FsZW5kYXItY29udHJvbC1hY3RpdmVdPVwidmlldyA9PSAnY2xvY2snICYmICFfaG91clZpZXdcIlxuICAgICAgW0Bjb250cm9sQWN0aXZlXT1cInZpZXcgPT0gJ2Nsb2NrJyAmJiAhX2hvdXJWaWV3ID8gJ2FjdGl2ZScgOiAnJ1wiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIl9pbnRsLnN3aXRjaFRvTWludXRlVmlld0xhYmVsXCJcbiAgICAgIChjbGljayk9XCJfc2hvd01pbnV0ZVZpZXcoKVwiPlxuICAgICAgICB7eyBfbWludXRlQnV0dG9uVGV4dCB9fVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1oZWFkZXItdGltZS1hbXBtXCIgKm5nSWY9XCJ0d2VsdmVIb3VyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWNvbnRyb2xcIlxuICAgICAgW2NsYXNzLm1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZV09XCJfaXNBbVwiXG4gICAgICBbQGNvbnRyb2xBY3RpdmVdPVwiX2lzQW0gPyAnYWN0aXZlJyA6ICcnXCJcbiAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuc2V0VG9BTUxhYmVsXCJcbiAgICAgIChjbGljayk9XCJfdG9nZ2xlQW1QbSh0cnVlKVwiPlxuICAgICAgICBBTVxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWNvbnRyb2xcIlxuICAgICAgW2NsYXNzLm1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZV09XCIhX2lzQW1cIlxuICAgICAgW0Bjb250cm9sQWN0aXZlXT1cIiFfaXNBbSA/ICdhY3RpdmUnIDogJydcIlxuICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfaW50bC5zZXRUb1BNTGFiZWxcIlxuICAgICAgKGNsaWNrKT1cIl90b2dnbGVBbVBtKGZhbHNlKVwiPlxuICAgICAgICBQTVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgW2NsYXNzXT1cIidtYXQtY2FsZW5kYXItY29udGVudCBtYXQtY2FsZW5kYXItdmlldy0nICsgdmlld1wiPlxuXG4gIDxkaXYgY2xhc3M9XCJtYXQtY2FsZW5kYXItaGVhZGluZ1wiICpuZ0lmPVwidmlldyA9PT0gJ21vbnRoJyB8fCB2aWV3ID09PSAneWVhcidcIj5cbiAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiBjbGFzcz1cIm1hdC1jYWxlbmRhci1wcmV2aW91cy1idXR0b25cIlxuICAgICAgKGNsaWNrKT1cIl9wcmV2aW91c0NsaWNrZWQoKVwiIFthdHRyLmRpc2FibGVkXT1cIiFfcHJldmlvdXNFbmFibGVkKCkgPyAnJyA6IG51bGxcIlxuICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfcHJldkJ1dHRvbkxhYmVsXCI+XG4gICAgPC9idXR0b24+XG5cbiAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRpbmctcGVyaW9kIG1hdC1jYWxlbmRhci1jb250cm9sIG1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZVwiXG4gICAgW0BzbGlkZUNhbGVuZGFyXT1cIl9hbmltYXRpb25EaXJcIiAoQHNsaWRlQ2FsZW5kYXIuZG9uZSk9XCJfYW5pbWF0aW9uRGlyID0gJydcIlxuICAgIChjbGljayk9XCJfY3VycmVudFBlcmlvZENsaWNrZWQoKVwiXG4gICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfcGVyaW9kQnV0dG9uTGFiZWxcIj5cbiAgICAgIDxzdHJvbmc+e3sgX3BlcmlvZEJ1dHRvblRleHQgfX08L3N0cm9uZz5cbiAgICA8L2J1dHRvbj5cblxuICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLW5leHQtYnV0dG9uXCJcbiAgICAgIChjbGljayk9XCJfbmV4dENsaWNrZWQoKVwiIFthdHRyLmRpc2FibGVkXT1cIiFfbmV4dEVuYWJsZWQoKSA/ICcnIDogbnVsbFwiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIl9uZXh0QnV0dG9uTGFiZWxcIj5cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1tYWluXCIgW25nU3dpdGNoXT1cInZpZXdcIiBjZGtNb25pdG9yU3VidHJlZUZvY3VzIHRhYmluZGV4PVwiLTFcIj5cblxuICAgIDxtYXQtY2xvY2stdmlld1xuICAgICAgKm5nU3dpdGNoQ2FzZT1cIidjbG9jaydcIlxuICAgICAgWyhhY3RpdmVEYXRlKV09XCJhY3RpdmVEYXRlXCJcbiAgICAgIFtzZWxlY3RlZF09XCJzZWxlY3RlZFwiXG4gICAgICBbZGF0ZUZpbHRlcl09XCJfZGF0ZUZpbHRlckZvclZpZXdzXCJcbiAgICAgIFtjbG9ja1N0ZXBdPVwiY2xvY2tTdGVwXCJcbiAgICAgIFt0d2VsdmVIb3VyXT1cInR3ZWx2ZUhvdXJcIlxuICAgICAgW2hvdXJWaWV3XT1cIl9ob3VyVmlld1wiXG4gICAgICAoc2VsZWN0ZWRUaW1lKT1cIl90aW1lU2VsZWN0ZWQoJGV2ZW50KVwiXG4gICAgICAoc2VsZWN0ZWRDaGFuZ2UpPVwiX3RpbWVDaGFuZ2VkKCRldmVudClcIlxuICAgICAgKGNoYW5nZVZpZXcpPVwiX2hvdXJWaWV3ID0gIV9ob3VyVmlld1wiPlxuICAgIDwvbWF0LWNsb2NrLXZpZXc+XG5cbiAgICA8bWF0LW1vbnRoLXZpZXdcbiAgICAgICpuZ1N3aXRjaENhc2U9XCInbW9udGgnXCJcbiAgICAgIFsoYWN0aXZlRGF0ZSldPVwiYWN0aXZlRGF0ZVwiXG4gICAgICBbc2VsZWN0ZWRdPVwic2VsZWN0ZWRcIlxuICAgICAgW2RhdGVGaWx0ZXJdPVwiX2RhdGVGaWx0ZXJGb3JWaWV3c1wiXG4gICAgICBbbWF4RGF0ZV09XCJtYXhEYXRlXCJcbiAgICAgIFttaW5EYXRlXT1cIm1pbkRhdGVcIlxuICAgICAgW2FuaW1hdGlvbkRpcl09XCJfYW5pbWF0aW9uRGlyXCJcbiAgICAgIChzZWxlY3RlZENoYW5nZSk9XCJfZGF0ZVNlbGVjdGVkKCRldmVudClcIlxuICAgICAgKF91c2VyU2VsZWN0aW9uKT1cIl9zaG93SG91clZpZXcoKVwiPlxuICAgIDwvbWF0LW1vbnRoLXZpZXc+XG5cbiAgICA8bWF0LXllYXItdmlld1xuICAgICAgKm5nU3dpdGNoQ2FzZT1cIid5ZWFyJ1wiXG4gICAgICBbKGFjdGl2ZURhdGUpXT1cImFjdGl2ZURhdGVcIlxuICAgICAgW3NlbGVjdGVkXT1cInNlbGVjdGVkXCJcbiAgICAgIFtkYXRlRmlsdGVyXT1cIl9kYXRlRmlsdGVyRm9yVmlld3NcIlxuICAgICAgW21heERhdGVdPVwibWF4RGF0ZVwiXG4gICAgICBbbWluRGF0ZV09XCJtaW5EYXRlXCJcbiAgICAgIFthbmltYXRpb25EaXJdPVwiX2FuaW1hdGlvbkRpclwiXG4gICAgICAoc2VsZWN0ZWRDaGFuZ2UpPVwiX21vbnRoU2VsZWN0ZWQoJGV2ZW50KVwiPlxuICAgIDwvbWF0LXllYXItdmlldz5cblxuICAgIDxtYXQteWVhcnMtdmlld1xuICAgICAgKm5nU3dpdGNoQ2FzZT1cIid5ZWFycydcIlxuICAgICAgWyhhY3RpdmVEYXRlKV09XCJhY3RpdmVEYXRlXCJcbiAgICAgIFtzZWxlY3RlZF09XCJzZWxlY3RlZFwiXG4gICAgICBbZGF0ZUZpbHRlcl09XCJfZGF0ZUZpbHRlckZvclZpZXdzXCJcbiAgICAgIFttYXhEYXRlXT1cIm1heERhdGVcIlxuICAgICAgW21pbkRhdGVdPVwibWluRGF0ZVwiXG4gICAgICAoc2VsZWN0ZWRDaGFuZ2UpPVwiX3llYXJTZWxlY3RlZCgkZXZlbnQpXCI+XG4gICAgPC9tYXQteWVhcnMtdmlldz5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1mb290ZXJcIj5cbiAgICA8YnV0dG9uIG1hdC1idXR0b25cbiAgICAoY2xpY2spPVwiX2NhbmNlbENsaWNrZWQoKVwiXG4gICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfaW50bC5idXR0b25DYW5jZWxMYWJlbFwiPlxuICAgICAge3sgX2ludGwuYnV0dG9uQ2FuY2VsVGV4dCB9fVxuICAgIDwvYnV0dG9uPlxuXG4gICAgPGJ1dHRvbiBtYXQtYnV0dG9uXG4gICAgKGNsaWNrKT1cIl9zdWJtaXRDbGlja2VkKClcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuYnV0dG9uU3VibWl0TGFiZWxcIj5cbiAgICAgIHt7IF9pbnRsLmJ1dHRvblN1Ym1pdFRleHQgfX1cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gIC8vIHN0eWxlVXJsczogWydjYWxlbmRhci5jc3MnXSxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnbWF0LWNhbGVuZGFyJ1xuICB9LFxuICBhbmltYXRpb25zOiBbbWF0RGF0ZXBpY2tlckFuaW1hdGlvbnMuY29udHJvbEFjdGl2ZSwgbWF0RGF0ZXBpY2tlckFuaW1hdGlvbnMuc2xpZGVDYWxlbmRhcl0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZVxufSlcbmV4cG9ydCBjbGFzcyBNYXRDYWxlbmRhcjxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0NoZWNrZWQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfaW50bENoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVXNlZCBmb3Igc2NoZWR1bGluZyB0aGF0IGZvY3VzIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgYWN0aXZlIGNlbGwgb24gdGhlIG5leHQgdGljay5cbiAgICogV2UgbmVlZCB0byBzY2hlZHVsZSBpdCwgcmF0aGVyIHRoYW4gZG8gaXQgaW1tZWRpYXRlbHksIGJlY2F1c2Ugd2UgaGF2ZSB0byB3YWl0XG4gICAqIGZvciBBbmd1bGFyIHRvIHJlLWV2YWx1YXRlIHRoZSB2aWV3IGNoaWxkcmVuLlxuICAgKi9cbiAgcHJpdmF0ZSBfbW92ZUZvY3VzT25OZXh0VGljayA9IGZhbHNlO1xuXG4gIC8qKiBBIGRhdGUgcmVwcmVzZW50aW5nIHRoZSBwZXJpb2QgKG1vbnRoIG9yIHllYXIpIHRvIHN0YXJ0IHRoZSBjYWxlbmRhciBpbi4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHN0YXJ0QXQoKTogRCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9zdGFydEF0O1xuICB9XG4gIHNldCBzdGFydEF0KHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgfVxuICBwcml2YXRlIF9zdGFydEF0OiBEIHwgbnVsbDtcblxuICAvKiogVGhlIHR5cGUgb2YgdmFsdWUgaGFuZGxlZCBieSB0aGUgY2FsZW5kYXIuICovXG4gIEBJbnB1dCgpIHR5cGU6IE1hdENhbGVuZGFyVHlwZSA9ICdkYXRlJztcblxuICAvKiogV2hpY2ggdmlldyB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIHN0YXJ0ZWQgaW4uICovXG4gIEBJbnB1dCgpIHN0YXJ0VmlldzogTWF0Q2FsZW5kYXJWaWV3ID0gJ21vbnRoJztcblxuICAvKiogQ3VycmVudCBjYWxlbmRhciB2aWV3ICovXG4gIHZpZXc6IE1hdENhbGVuZGFyVmlldztcblxuICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgc2VsZWN0ZWQoKTogRCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgfVxuICBzZXQgc2VsZWN0ZWQodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgICBpZiAodGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX3NlbGVjdGVkO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9zZWxlY3RlZDogRCB8IG51bGw7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1pbkRhdGUoKTogRCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9taW5EYXRlO1xuICB9XG4gIHNldCBtaW5EYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX21pbkRhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgfVxuICBwcml2YXRlIF9taW5EYXRlOiBEIHwgbnVsbDtcblxuICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgbWF4RGF0ZSgpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX21heERhdGU7XG4gIH1cbiAgc2V0IG1heERhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWF4RGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIHByaXZhdGUgX21heERhdGU6IEQgfCBudWxsO1xuXG4gIC8qKiBBIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGRhdGVzIGFyZSBzZWxlY3RhYmxlLiAqL1xuICBASW5wdXQoKSBkYXRlRmlsdGVyOiAoZGF0ZTogRCwgdW5pdD86IHN0cmluZykgPT4gYm9vbGVhbjtcblxuICAvKiogQ2xvY2sgaW50ZXJ2YWwgKi9cbiAgQElucHV0KCkgY2xvY2tTdGVwID0gMTtcblxuICAvKiogQ2xvY2sgaG91ciBmb3JtYXQgKi9cbiAgQElucHV0KCkgdHdlbHZlSG91ciA9IGZhbHNlO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZSBjaGFuZ2VzLiAqL1xuICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gYW55IGRhdGUgaXMgc2VsZWN0ZWQuICovXG4gIEBPdXRwdXQoKSBfdXNlclNlbGVjdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGNsb2NrIHZpZXcgY29tcG9uZW50LiAqL1xuICBAVmlld0NoaWxkKE1hdENsb2NrVmlldykgY2xvY2tWaWV3OiBNYXRDbG9ja1ZpZXc8RD47XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBtb250aCB2aWV3IGNvbXBvbmVudC4gKi9cbiAgQFZpZXdDaGlsZChNYXRNb250aFZpZXcpIG1vbnRoVmlldzogTWF0TW9udGhWaWV3PEQ+O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgeWVhciB2aWV3IGNvbXBvbmVudC4gKi9cbiAgQFZpZXdDaGlsZChNYXRZZWFyVmlldykgeWVhclZpZXc6IE1hdFllYXJWaWV3PEQ+O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgeWVhcnMgdmlldyBjb21wb25lbnQuICovXG4gIEBWaWV3Q2hpbGQoTWF0WWVhcnNWaWV3KSB5ZWFyc1ZpZXc6IE1hdFllYXJzVmlldzxEPjtcblxuICAvKiogRGF0ZSBmaWx0ZXIgZm9yIHRoZSBtb250aCBhbmQgeWVhciB2aWV3cy4gKi9cbiAgX2RhdGVGaWx0ZXJGb3JWaWV3cyA9IChkYXRlOiBELCB1bml0ID0gJ21pbnV0ZScpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgISFkYXRlICYmXG4gICAgICAoIXRoaXMuZGF0ZUZpbHRlciB8fCB0aGlzLmRhdGVGaWx0ZXIoZGF0ZSkpICYmXG4gICAgICAoIXRoaXMubWluRGF0ZSB8fCB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShkYXRlLCB0aGlzLm1pbkRhdGUsIHVuaXQpID49IDApICYmXG4gICAgICAoIXRoaXMubWF4RGF0ZSB8fCB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShkYXRlLCB0aGlzLm1heERhdGUsIHVuaXQpIDw9IDApXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYWN0aXZlIGRhdGUuIFRoaXMgZGV0ZXJtaW5lcyB3aGljaCB0aW1lIHBlcmlvZCBpcyBzaG93biBhbmQgd2hpY2ggZGF0ZSBpc1xuICAgKiBoaWdobGlnaHRlZCB3aGVuIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gICAqL1xuICBnZXQgYWN0aXZlRGF0ZSgpOiBEIHtcbiAgICByZXR1cm4gdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGU7XG4gIH1cbiAgc2V0IGFjdGl2ZURhdGUodmFsdWU6IEQpIHtcbiAgICBjb25zdCBvbGRBY3RpdmVEYXRlID0gdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGU7XG4gICAgdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5jbGFtcERhdGUodmFsdWUsIHRoaXMubWluRGF0ZSwgdGhpcy5tYXhEYXRlKTtcbiAgICB0aGlzLl9pc0FtID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0SG91cnModGhpcy5fY2xhbXBlZEFjdGl2ZURhdGUpIDwgMTI7XG5cbiAgICBjb25zdCB1bml0ID0gdGhpcy52aWV3ID09PSAneWVhcicgPyAneWVhcicgOiAnbW9udGgnO1xuICAgIGNvbnN0IGRpZmYgPSB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShvbGRBY3RpdmVEYXRlLCB0aGlzLl9jbGFtcGVkQWN0aXZlRGF0ZSwgdW5pdCk7XG4gICAgaWYgKGRpZmYpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkRpciA9IGRpZmYgPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGxhYmVsc1xuICAgIGNvbnN0IGRheSA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERheU9mV2Vlayh0aGlzLmFjdGl2ZURhdGUpO1xuICAgIGxldCBob3VycyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldEhvdXJzKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgaWYgKHRoaXMudHdlbHZlSG91cikge1xuICAgICAgaG91cnMgPSBob3VycyA9PT0gMCA/IDEyIDogaG91cnMgPiAxMiA/IGhvdXJzIC0gMTIgOiBob3VycztcbiAgICB9XG4gICAgY29uc3QgbWludXRlcyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1pbnV0ZXModGhpcy5hY3RpdmVEYXRlKTtcblxuICAgIHN3aXRjaCAodGhpcy52aWV3KSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChcbiAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUsXG4gICAgICAgICAgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5tb250aFllYXJMYWJlbFxuICAgICAgICApO1xuICAgIH1cbiAgICB0aGlzLl95ZWFyQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKS50b1N0cmluZygpO1xuICAgIHRoaXMuX21vbnRoZGF5QnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhEYXlMYWJlbFxuICAgICk7XG4gICAgdGhpcy5fZGF5QnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERheU9mV2Vla05hbWVzKCdzaG9ydCcpW2RheV07XG4gICAgdGhpcy5faG91ckJ1dHRvblRleHQgPSBob3Vycy50b1N0cmluZygpO1xuICAgIHRoaXMuX21pbnV0ZUJ1dHRvblRleHQgPSAoJzAwJyArIG1pbnV0ZXMpLnNsaWNlKC0yKTtcblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuICBwcml2YXRlIF9jbGFtcGVkQWN0aXZlRGF0ZTogRDtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgaXMgaW4gbW9udGggdmlldy4gKi9cbiAgZ2V0IGN1cnJlbnRWaWV3KCk6IE1hdENhbGVuZGFyVmlldyB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3O1xuICB9XG4gIHNldCBjdXJyZW50Vmlldyh2YWx1ZTogTWF0Q2FsZW5kYXJWaWV3KSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSB2YWx1ZTtcbiAgICB0aGlzLl9tb3ZlRm9jdXNPbk5leHRUaWNrID0gdHJ1ZTtcbiAgfVxuICBwcml2YXRlIF9jdXJyZW50VmlldzogTWF0Q2FsZW5kYXJWaWV3O1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGVyZSBpcyBhIHN0YXRlIGNoYW5nZSB0aGF0IHRoZSBoZWFkZXIgbWF5IG5lZWQgdG8gcmVzcG9uZCB0by5cbiAgICovXG4gIHN0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIEFuaW1hdGlvbnMgaGFuZGxlciAqL1xuICBfYW5pbWF0aW9uRGlyOiBzdHJpbmc7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGFjdGl2ZSBkYXRlIGlzIEFNIG9yIG5vdCAqL1xuICBfaXNBbTogYm9vbGVhbjtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgcHJvY2VzcyB0aGUgdGltZS4gKi9cbiAgX2hhc1RpbWU6IGJvb2xlYW47XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIGluIGhvdXIgdmlldy4gKi9cbiAgX2hvdXJWaWV3OiBib29sZWFuID0gdHJ1ZTtcblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgY2FsZW5kYXIgaGVhZGVyIGJ1dHRvbnMuICovXG4gIF95ZWFyQnV0dG9uVGV4dDogc3RyaW5nO1xuXG4gIF9kYXlCdXR0b25UZXh0OiBzdHJpbmc7XG5cbiAgX21vbnRoZGF5QnV0dG9uVGV4dDogc3RyaW5nO1xuXG4gIF9ob3VyQnV0dG9uVGV4dDogc3RyaW5nO1xuXG4gIF9taW51dGVCdXR0b25UZXh0OiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBsYWJlbCBmb3IgdGhlIGN1cnJlbnQgY2FsZW5kYXIgdmlldy4gKi9cbiAgX3BlcmlvZEJ1dHRvblRleHQ6IHN0cmluZztcblxuICBfcGVyaW9kQnV0dG9uTGFiZWw6IHN0cmluZztcblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgdGhlIHByZXZpb3VzIGJ1dHRvbi4gKi9cbiAgX3ByZXZCdXR0b25MYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBUaGUgbGFiZWwgZm9yIHRoZSB0aGUgbmV4dCBidXR0b24uICovXG4gIF9uZXh0QnV0dG9uTGFiZWw6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgX2ludGw6IE1hdERhdGVwaWNrZXJJbnRsLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxEPixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoTUFUX0RBVEVfRk9STUFUUylcbiAgICBwcml2YXRlIF9kYXRlRm9ybWF0czogTWF0RGF0ZUZvcm1hdHMsXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmXG4gICkge1xuICAgIGlmICghdGhpcy5fZGF0ZUFkYXB0ZXIpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdEYXRlQWRhcHRlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdNQVRfREFURV9GT1JNQVRTJyk7XG4gICAgfVxuXG4gICAgdGhpcy5faW50bENoYW5nZXMgPSBfaW50bC5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBfY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5zdGFydEF0IHx8IHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCk7XG5cbiAgICB0aGlzLmNoYW5nZVZpZXcodGhpcy5zdGFydFZpZXcsIGZhbHNlKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICBpZiAodGhpcy5fbW92ZUZvY3VzT25OZXh0VGljaykge1xuICAgICAgdGhpcy5fbW92ZUZvY3VzT25OZXh0VGljayA9IGZhbHNlO1xuICAgICAgdGhpcy5mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9pbnRsQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgdGhpcy5faGFzVGltZSA9IHRoaXMudHlwZS5pbmRleE9mKCd0aW1lJykgPj0gMDtcbiAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzLnNlbGVjdGVkIHx8IGNoYW5nZXMubWluRGF0ZSB8fCBjaGFuZ2VzLm1heERhdGUgfHwgY2hhbmdlcy5kYXRlRmlsdGVyO1xuXG4gICAgaWYgKGNoYW5nZSAmJiAhY2hhbmdlLmZpcnN0Q2hhbmdlKSB7XG4gICAgICBjb25zdCB2aWV3ID0gdGhpcy5fZ2V0Q3VycmVudFZpZXdDb21wb25lbnQoKTtcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gYGRldGVjdENoYW5nZXNgIG1hbnVhbGx5IGhlcmUsIGJlY2F1c2UgdGhlIGBtaW5EYXRlYCwgYG1heERhdGVgIGV0Yy4gYXJlXG4gICAgICAgIC8vIHBhc3NlZCBkb3duIHRvIHRoZSB2aWV3IHZpYSBkYXRhIGJpbmRpbmdzIHdoaWNoIHdvbid0IGJlIHVwLXRvLWRhdGUgd2hlbiB3ZSBjYWxsIGBfaW5pdGAuXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdmlldy5faW5pdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIGNoYW5nZVZpZXcodmlldywgZm9jdXMgPSB0cnVlKSB7XG4gICAgc3dpdGNoICh2aWV3KSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgIHRoaXMuX3BlcmlvZEJ1dHRvbkxhYmVsID0gdGhpcy5faW50bC5zd2l0Y2hUb1llYXJzVmlld0xhYmVsO1xuICAgICAgICB0aGlzLl9uZXh0QnV0dG9uTGFiZWwgPSB0aGlzLl9pbnRsLm5leHRZZWFyTGFiZWw7XG4gICAgICAgIHRoaXMuX3ByZXZCdXR0b25MYWJlbCA9IHRoaXMuX2ludGwucHJldlllYXJMYWJlbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIHRoaXMuX3BlcmlvZEJ1dHRvblRleHQgPSB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoXG4gICAgICAgICAgdGhpcy5hY3RpdmVEYXRlLFxuICAgICAgICAgIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyTGFiZWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uTGFiZWwgPSB0aGlzLl9pbnRsLnN3aXRjaFRvWWVhclZpZXdMYWJlbDtcbiAgICAgICAgdGhpcy5fbmV4dEJ1dHRvbkxhYmVsID0gdGhpcy5faW50bC5uZXh0TW9udGhMYWJlbDtcbiAgICAgICAgdGhpcy5fcHJldkJ1dHRvbkxhYmVsID0gdGhpcy5faW50bC5wcmV2TW9udGhMYWJlbDtcbiAgICB9XG5cbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5fbW92ZUZvY3VzT25OZXh0VGljayA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9jdXNBY3RpdmVDZWxsKCkge1xuICAgIHRoaXMuX2dldEN1cnJlbnRWaWV3Q29tcG9uZW50KCkuX2ZvY3VzQWN0aXZlQ2VsbCgpO1xuICB9XG5cbiAgX3N1Ym1pdENsaWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgdGhpcy5fdXNlclNlbGVjdGlvbi5lbWl0KCk7XG4gIH1cblxuICBfY2FuY2VsQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyU2VsZWN0aW9uLmVtaXQoKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIGRhdGUgc2VsZWN0aW9uIGluIHRoZSBjbG9jayB2aWV3LiAqL1xuICBfdGltZUNoYW5nZWQoZGF0ZTogRCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBkYXRlO1xuICB9XG5cbiAgX3RpbWVTZWxlY3RlZChkYXRlOiBEKTogdm9pZCB7XG4gICAgLy8gaWYgKHRoaXMuYXV0b09rICYmIHRoaXMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgLy8gICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoZGF0ZSk7XG4gICAgLy8gICB0aGlzLl91c2VyU2VsZWN0aW9uLmVtaXQoKTtcbiAgICAvLyB9XG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGU7XG4gIH1cblxuICAvKiogSGFuZGxlcyBkYXRlIHNlbGVjdGlvbiBpbiB0aGUgbW9udGggdmlldy4gKi9cbiAgX2RhdGVTZWxlY3RlZChkYXRlOiBEKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGU7XG4gICAgaWYgKHRoaXMuX2hhc1RpbWUpIHtcbiAgICAgIHRoaXMuY2hhbmdlVmlldygnY2xvY2snKTtcbiAgICB9XG4gIH1cblxuICAvKiogSGFuZGxlcyBtb250aCBzZWxlY3Rpb24gaW4gdGhlIHllYXIgdmlldy4gKi9cbiAgX21vbnRoU2VsZWN0ZWQobW9udGg6IEQpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGVkID0gbW9udGg7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KCdtb250aCcpO1xuICB9XG5cbiAgX3llYXJTZWxlY3RlZCh5ZWFyOiBEKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHllYXI7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KCd5ZWFyJyk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgcGVyaW9kIGxhYmVsLiAqL1xuICBfY3VycmVudFBlcmlvZENsaWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KHRoaXMudmlldyA9PT0gJ21vbnRoJyA/ICd5ZWFyJyA6ICd5ZWFycycpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgdXNlciBjbGlja3Mgb24gdGhlIHByZXZpb3VzIGJ1dHRvbi4gKi9cbiAgX3ByZXZpb3VzQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9uYXZDYWxlbmRhcigtMSk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgbmV4dCBidXR0b24uICovXG4gIF9uZXh0Q2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9uYXZDYWxlbmRhcigxKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHVzZXIgY2xpY2tzIG9uIHRoZSB0aW1lIGxhYmVscy4gKi9cbiAgX3Nob3dIb3VyVmlldygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faGFzVGltZSkge1xuICAgICAgdGhpcy5faG91clZpZXcgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFuZ2VWaWV3KCdjbG9jaycpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93TWludXRlVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl9ob3VyVmlldyA9IGZhbHNlO1xuICAgIHRoaXMuY2hhbmdlVmlldygnY2xvY2snKTtcbiAgfVxuXG4gIF90b2dnbGVBbVBtKGFtKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2lzQW0gIT09IGFtKSB7XG4gICAgICBjb25zdCBkYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJIb3Vycyh0aGlzLmFjdGl2ZURhdGUsIHRoaXMuX2lzQW0gPyAxMiA6IC0xMik7XG4gICAgICBpZiAodGhpcy5fZGF0ZUZpbHRlckZvclZpZXdzKGRhdGUsICdtaW51dGUnKSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcHJldmlvdXMgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBfcHJldmlvdXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5taW5EYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLm1pbkRhdGUgfHwgIXRoaXMuX2lzU2FtZVZpZXcodGhpcy5hY3RpdmVEYXRlLCB0aGlzLm1pbkRhdGUpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG5leHQgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBfbmV4dEVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLm1heERhdGUgfHwgIXRoaXMuX2lzU2FtZVZpZXcodGhpcy5hY3RpdmVEYXRlLCB0aGlzLm1heERhdGUpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgY2FsZW5kYXIgZGlmZnMuICovXG4gIF9uYXZDYWxlbmRhcihkaWZmKTogdm9pZCB7XG4gICAgc3dpdGNoICh0aGlzLnZpZXcpIHtcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuYWN0aXZlRGF0ZSwgZGlmZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLmFjdGl2ZURhdGUsIGRpZmYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nsb2NrJzpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5faG91clZpZXdcbiAgICAgICAgICA/IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFySG91cnModGhpcy5hY3RpdmVEYXRlLCBkaWZmKVxuICAgICAgICAgIDogdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNaW51dGVzKHRoaXMuYWN0aXZlRGF0ZSwgZGlmZik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSB0d28gZGF0ZXMgcmVwcmVzZW50IHRoZSBzYW1lIHZpZXcgaW4gdGhlIGN1cnJlbnQgdmlldyBtb2RlIChtb250aCBvciB5ZWFyKS4gKi9cbiAgcHJpdmF0ZSBfaXNTYW1lVmlldyhkYXRlMTogRCwgZGF0ZTI6IEQpOiBib29sZWFuIHtcbiAgICBzd2l0Y2ggKHRoaXMudmlldykge1xuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKGRhdGUxKSA9PT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMik7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIGNvbnN0IG1vbnRoWWVhciA9IHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyTGFiZWw7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KGRhdGUxLCBtb250aFllYXIpID09PSB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZTIsIG1vbnRoWWVhcilcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgJ2Nsb2NrJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IGhvdXJNaW51dGUgPSB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LnRpbWVMYWJlbDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZTEsIGhvdXJNaW51dGUpID09PVxuICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChkYXRlMiwgaG91ck1pbnV0ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBUaGUgZ2l2ZW4gb2JqZWN0IGlmIGl0IGlzIGJvdGggYSBkYXRlIGluc3RhbmNlIGFuZCB2YWxpZCwgb3RoZXJ3aXNlIG51bGwuXG4gICAqL1xuICBwcml2YXRlIF9nZXRWYWxpZERhdGVPck51bGwob2JqOiBhbnkpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyLmlzRGF0ZUluc3RhbmNlKG9iaikgJiYgdGhpcy5fZGF0ZUFkYXB0ZXIuaXNWYWxpZChvYmopID8gb2JqIDogbnVsbDtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudCBjYWxlbmRhciB2aWV3LiAqL1xuICBwcml2YXRlIF9nZXRDdXJyZW50Vmlld0NvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9ja1ZpZXcgfHwgdGhpcy5tb250aFZpZXcgfHwgdGhpcy55ZWFyVmlldyB8fCB0aGlzLnllYXJzVmlldztcbiAgfVxufVxuIl19