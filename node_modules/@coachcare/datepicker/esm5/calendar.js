/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { Subject } from 'rxjs';
import { MatClockView } from './clock-view';
import { MAT_DATE_FORMATS } from './core/index';
import { DateAdapter } from './core/index';
import { matDatepickerAnimations } from './datepicker-animations';
import { createMissingDateImplError } from './datepicker-errors';
import { MatDatepickerIntl } from './datepicker-intl';
import { MatMonthView } from './month-view';
import { MatYearView } from './year-view';
import { MatYearsView } from './years-view';
/**
 * A calendar that is used as part of the datepicker.
 * \@docs-private
 * @template D
 */
var MatCalendar = /** @class */ (function () {
    function MatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
        var _this = this;
        this._intl = _intl;
        this._dateAdapter = _dateAdapter;
        this._dateFormats = _dateFormats;
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * Used for scheduling that focus should be moved to the active cell on the next tick.
         * We need to schedule it, rather than do it immediately, because we have to wait
         * for Angular to re-evaluate the view children.
         */
        this._moveFocusOnNextTick = false;
        /** The type of value handled by the calendar. */
        this.type = 'date';
        /** Which view the calendar should be started in. */
        this.startView = 'month';
        /** Clock interval */
        this.clockStep = 1;
        /** Clock hour format */
        this.twelveHour = false;
        /** Emits when the currently selected date changes. */
        this.selectedChange = new EventEmitter();
        /** Emits when any date is selected. */
        this._userSelection = new EventEmitter();
        /** Date filter for the month and year views. */
        this._dateFilterForViews = function (date, unit) {
            if (unit === void 0) { unit = 'minute'; }
            return (!!date &&
                (!_this.dateFilter || _this.dateFilter(date)) &&
                (!_this.minDate || _this._dateAdapter.compareDate(date, _this.minDate, unit) >= 0) &&
                (!_this.maxDate || _this._dateAdapter.compareDate(date, _this.maxDate, unit) <= 0));
        };
        /**
         * Emits whenever there is a state change that the header may need to respond to.
         */
        this.stateChanges = new Subject();
        /** Whether the calendar is in hour view. */
        this._hourView = true;
        if (!this._dateAdapter) {
            throw createMissingDateImplError('DateAdapter');
        }
        if (!this._dateFormats) {
            throw createMissingDateImplError('MAT_DATE_FORMATS');
        }
        this._intlChanges = _intl.changes.subscribe(function () {
            _changeDetectorRef.markForCheck();
            _this.stateChanges.next();
        });
    }
    Object.defineProperty(MatCalendar.prototype, "startAt", {
        /** A date representing the period (month or year) to start the calendar in. */
        get: /**
         * A date representing the period (month or year) to start the calendar in.
         * @return {?}
         */
        function () {
            return this._startAt;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCalendar.prototype, "selected", {
        /** The currently selected date. */
        get: /**
         * The currently selected date.
         * @return {?}
         */
        function () {
            return this._selected;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            if (this._selected) {
                this.activeDate = this._selected;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCalendar.prototype, "minDate", {
        /** The minimum selectable date. */
        get: /**
         * The minimum selectable date.
         * @return {?}
         */
        function () {
            return this._minDate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCalendar.prototype, "maxDate", {
        /** The maximum selectable date. */
        get: /**
         * The maximum selectable date.
         * @return {?}
         */
        function () {
            return this._maxDate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCalendar.prototype, "activeDate", {
        /**
         * The current active date. This determines which time period is shown and which date is
         * highlighted when using keyboard navigation.
         */
        get: /**
         * The current active date. This determines which time period is shown and which date is
         * highlighted when using keyboard navigation.
         * @return {?}
         */
        function () {
            return this._clampedActiveDate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var oldActiveDate = this._clampedActiveDate;
            this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
            this._isAm = this._dateAdapter.getHours(this._clampedActiveDate) < 12;
            /** @type {?} */
            var unit = this.view === 'year' ? 'year' : 'month';
            /** @type {?} */
            var diff = this._dateAdapter.compareDate(oldActiveDate, this._clampedActiveDate, unit);
            if (diff) {
                this._animationDir = diff > 0 ? 'left' : 'right';
            }
            // update the labels
            /** @type {?} */
            var day = this._dateAdapter.getDayOfWeek(this.activeDate);
            /** @type {?} */
            var hours = this._dateAdapter.getHours(this.activeDate);
            if (this.twelveHour) {
                hours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
            }
            /** @type {?} */
            var minutes = this._dateAdapter.getMinutes(this.activeDate);
            switch (this.view) {
                case 'year':
                    this._periodButtonText = this._dateAdapter.getYearName(this.activeDate);
                    break;
                default:
                    this._periodButtonText = this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthYearLabel);
            }
            this._yearButtonText = this._dateAdapter.getYear(this.activeDate).toString();
            this._monthdayButtonText = this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthDayLabel);
            this._dayButtonText = this._dateAdapter.getDayOfWeekNames('short')[day];
            this._hourButtonText = hours.toString();
            this._minuteButtonText = ('00' + minutes).slice(-2);
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCalendar.prototype, "currentView", {
        /** Whether the calendar is in month view. */
        get: /**
         * Whether the calendar is in month view.
         * @return {?}
         */
        function () {
            return this._currentView;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._currentView = value;
            this._moveFocusOnNextTick = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatCalendar.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.activeDate = this.startAt || this._dateAdapter.today();
        this.changeView(this.startView, false);
    };
    /**
     * @return {?}
     */
    MatCalendar.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        if (this._moveFocusOnNextTick) {
            this._moveFocusOnNextTick = false;
            this.focusActiveCell();
        }
    };
    /**
     * @return {?}
     */
    MatCalendar.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._intlChanges.unsubscribe();
        this.stateChanges.complete();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MatCalendar.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this._hasTime = this.type.indexOf('time') >= 0;
        /** @type {?} */
        var change = changes.selected || changes.minDate || changes.maxDate || changes.dateFilter;
        if (change && !change.firstChange) {
            /** @type {?} */
            var view = this._getCurrentViewComponent();
            if (view) {
                // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                this._changeDetectorRef.detectChanges();
                view._init();
            }
        }
        this.stateChanges.next();
    };
    /**
     * @param {?} view
     * @param {?=} focus
     * @return {?}
     */
    MatCalendar.prototype.changeView = /**
     * @param {?} view
     * @param {?=} focus
     * @return {?}
     */
    function (view, focus) {
        if (focus === void 0) { focus = true; }
        switch (view) {
            case 'year':
                this._periodButtonText = this._dateAdapter.getYearName(this.activeDate);
                this._periodButtonLabel = this._intl.switchToYearsViewLabel;
                this._nextButtonLabel = this._intl.nextYearLabel;
                this._prevButtonLabel = this._intl.prevYearLabel;
                break;
            case 'month':
                this._periodButtonText = this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthYearLabel);
                this._periodButtonLabel = this._intl.switchToYearViewLabel;
                this._nextButtonLabel = this._intl.nextMonthLabel;
                this._prevButtonLabel = this._intl.prevMonthLabel;
        }
        this.view = view;
        if (focus) {
            this._moveFocusOnNextTick = true;
        }
    };
    /**
     * @return {?}
     */
    MatCalendar.prototype.focusActiveCell = /**
     * @return {?}
     */
    function () {
        this._getCurrentViewComponent()._focusActiveCell();
    };
    /**
     * @return {?}
     */
    MatCalendar.prototype._submitClicked = /**
     * @return {?}
     */
    function () {
        this.selectedChange.emit(this.activeDate);
        this._userSelection.emit();
    };
    /**
     * @return {?}
     */
    MatCalendar.prototype._cancelClicked = /**
     * @return {?}
     */
    function () {
        this._userSelection.emit();
    };
    /** Handles date selection in the clock view. */
    /**
     * Handles date selection in the clock view.
     * @param {?} date
     * @return {?}
     */
    MatCalendar.prototype._timeChanged = /**
     * Handles date selection in the clock view.
     * @param {?} date
     * @return {?}
     */
    function (date) {
        this.selected = date;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    MatCalendar.prototype._timeSelected = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        // if (this.autoOk && this.type === 'time') {
        //   this.selectedChange.emit(date);
        //   this._userSelection.emit();
        // }
        this.selected = date;
    };
    /** Handles date selection in the month view. */
    /**
     * Handles date selection in the month view.
     * @param {?} date
     * @return {?}
     */
    MatCalendar.prototype._dateSelected = /**
     * Handles date selection in the month view.
     * @param {?} date
     * @return {?}
     */
    function (date) {
        this.selected = date;
        if (this._hasTime) {
            this.changeView('clock');
        }
    };
    /** Handles month selection in the year view. */
    /**
     * Handles month selection in the year view.
     * @param {?} month
     * @return {?}
     */
    MatCalendar.prototype._monthSelected = /**
     * Handles month selection in the year view.
     * @param {?} month
     * @return {?}
     */
    function (month) {
        this.selected = month;
        this.changeView('month');
    };
    /**
     * @param {?} year
     * @return {?}
     */
    MatCalendar.prototype._yearSelected = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this.selected = year;
        this.changeView('year');
    };
    /** Handles user clicks on the period label. */
    /**
     * Handles user clicks on the period label.
     * @return {?}
     */
    MatCalendar.prototype._currentPeriodClicked = /**
     * Handles user clicks on the period label.
     * @return {?}
     */
    function () {
        this.changeView(this.view === 'month' ? 'year' : 'years');
    };
    /** Handles user clicks on the previous button. */
    /**
     * Handles user clicks on the previous button.
     * @return {?}
     */
    MatCalendar.prototype._previousClicked = /**
     * Handles user clicks on the previous button.
     * @return {?}
     */
    function () {
        this._navCalendar(-1);
    };
    /** Handles user clicks on the next button. */
    /**
     * Handles user clicks on the next button.
     * @return {?}
     */
    MatCalendar.prototype._nextClicked = /**
     * Handles user clicks on the next button.
     * @return {?}
     */
    function () {
        this._navCalendar(1);
    };
    /** Handles user clicks on the time labels. */
    /**
     * Handles user clicks on the time labels.
     * @return {?}
     */
    MatCalendar.prototype._showHourView = /**
     * Handles user clicks on the time labels.
     * @return {?}
     */
    function () {
        if (this._hasTime) {
            this._hourView = true;
            this.changeView('clock');
        }
    };
    /**
     * @return {?}
     */
    MatCalendar.prototype._showMinuteView = /**
     * @return {?}
     */
    function () {
        this._hourView = false;
        this.changeView('clock');
    };
    /**
     * @param {?} am
     * @return {?}
     */
    MatCalendar.prototype._toggleAmPm = /**
     * @param {?} am
     * @return {?}
     */
    function (am) {
        if (this._isAm !== am) {
            /** @type {?} */
            var date = this._dateAdapter.addCalendarHours(this.activeDate, this._isAm ? 12 : -12);
            if (this._dateFilterForViews(date, 'minute')) {
                this.selected = date;
            }
        }
    };
    /** Whether the previous period button is enabled. */
    /**
     * Whether the previous period button is enabled.
     * @return {?}
     */
    MatCalendar.prototype._previousEnabled = /**
     * Whether the previous period button is enabled.
     * @return {?}
     */
    function () {
        if (!this.minDate) {
            return true;
        }
        return !this.minDate || !this._isSameView(this.activeDate, this.minDate);
    };
    /** Whether the next period button is enabled. */
    /**
     * Whether the next period button is enabled.
     * @return {?}
     */
    MatCalendar.prototype._nextEnabled = /**
     * Whether the next period button is enabled.
     * @return {?}
     */
    function () {
        return !this.maxDate || !this._isSameView(this.activeDate, this.maxDate);
    };
    /** Handles calendar diffs. */
    /**
     * Handles calendar diffs.
     * @param {?} diff
     * @return {?}
     */
    MatCalendar.prototype._navCalendar = /**
     * Handles calendar diffs.
     * @param {?} diff
     * @return {?}
     */
    function (diff) {
        switch (this.view) {
            case 'year':
                this.activeDate = this._dateAdapter.addCalendarYears(this.activeDate, diff);
                break;
            case 'month':
                this.activeDate = this._dateAdapter.addCalendarMonths(this.activeDate, diff);
                break;
            case 'clock':
                this.activeDate = this._hourView
                    ? this._dateAdapter.addCalendarHours(this.activeDate, diff)
                    : this._dateAdapter.addCalendarMinutes(this.activeDate, diff);
                break;
        }
    };
    /** Whether the two dates represent the same view in the current view mode (month or year). */
    /**
     * Whether the two dates represent the same view in the current view mode (month or year).
     * @param {?} date1
     * @param {?} date2
     * @return {?}
     */
    MatCalendar.prototype._isSameView = /**
     * Whether the two dates represent the same view in the current view mode (month or year).
     * @param {?} date1
     * @param {?} date2
     * @return {?}
     */
    function (date1, date2) {
        switch (this.view) {
            case 'year':
                return this._dateAdapter.getYear(date1) === this._dateAdapter.getYear(date2);
            case 'month':
                /** @type {?} */
                var monthYear = this._dateFormats.display.monthYearLabel;
                return (this._dateAdapter.format(date1, monthYear) === this._dateAdapter.format(date2, monthYear));
            case 'clock':
            default:
                /** @type {?} */
                var hourMinute = this._dateFormats.display.timeLabel;
                return (this._dateAdapter.format(date1, hourMinute) ===
                    this._dateAdapter.format(date2, hourMinute));
        }
    };
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    /**
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    MatCalendar.prototype._getValidDateOrNull = /**
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    function (obj) {
        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;
    };
    /** Returns the component instance that corresponds to the current calendar view. */
    /**
     * Returns the component instance that corresponds to the current calendar view.
     * @return {?}
     */
    MatCalendar.prototype._getCurrentViewComponent = /**
     * Returns the component instance that corresponds to the current calendar view.
     * @return {?}
     */
    function () {
        return this.clockView || this.monthView || this.yearView || this.yearsView;
    };
    MatCalendar.decorators = [
        { type: Component, args: [{
                    selector: 'mat-calendar',
                    template: "<div [class]=\"'mat-calendar-header mat-calendar-type-' + type\">\n\n  <div class=\"mat-calendar-header-date\">\n    <button class=\"mat-calendar-header-date-year mat-calendar-control\"\n    [class.mat-calendar-control-active]=\"view == 'years'\"\n    [@controlActive]=\"view == 'years' ? 'active' : ''\"\n    [attr.aria-label]=\"_intl.switchToYearViewLabel\"\n    (click)=\"changeView('years')\">\n      {{ _yearButtonText }}\n    </button>\n\n    <button class=\"mat-calendar-header-date-month mat-calendar-control\"\n    [class.mat-calendar-control-active]=\"view == 'month' || view == 'year'\"\n    [@controlActive]=\"view == 'month' || view == 'year' ? 'active' : ''\"\n    [attr.aria-label]=\"_intl.switchToMonthViewLabel\"\n    (click)=\"changeView('month')\">\n      <span class=\"mat-calendar-header-date-dayname\">{{ _dayButtonText }}, </span>\n      <span class=\"mat-calendar-header-date-monthday\">{{ _monthdayButtonText }}</span>\n    </button>\n  </div>\n\n  <div class=\"mat-calendar-header-time\">\n    <div class=\"mat-calendar-header-time-hour\">\n      <button class=\"mat-calendar-control\"\n      [class.mat-calendar-control-active]=\"view == 'clock' && _hourView\"\n      [@controlActive]=\"view == 'clock' && _hourView ? 'active' : ''\"\n      [attr.aria-label]=\"_intl.switchToHourViewLabel\"\n      (click)=\"_showHourView()\">\n        {{ _hourButtonText }}\n      </button>\n      <span>:</span>\n      <button class=\"mat-calendar-control\"\n      [class.mat-calendar-control-active]=\"view == 'clock' && !_hourView\"\n      [@controlActive]=\"view == 'clock' && !_hourView ? 'active' : ''\"\n      [attr.aria-label]=\"_intl.switchToMinuteViewLabel\"\n      (click)=\"_showMinuteView()\">\n        {{ _minuteButtonText }}\n      </button>\n    </div>\n    <div class=\"mat-calendar-header-time-ampm\" *ngIf=\"twelveHour\">\n      <button class=\"mat-calendar-control\"\n      [class.mat-calendar-control-active]=\"_isAm\"\n      [@controlActive]=\"_isAm ? 'active' : ''\"\n      [attr.aria-label]=\"_intl.setToAMLabel\"\n      (click)=\"_toggleAmPm(true)\">\n        AM\n      </button>\n      <button class=\"mat-calendar-control\"\n      [class.mat-calendar-control-active]=\"!_isAm\"\n      [@controlActive]=\"!_isAm ? 'active' : ''\"\n      [attr.aria-label]=\"_intl.setToPMLabel\"\n      (click)=\"_toggleAmPm(false)\">\n        PM\n      </button>\n    </div>\n  </div>\n</div>\n\n<div [class]=\"'mat-calendar-content mat-calendar-view-' + view\">\n\n  <div class=\"mat-calendar-heading\" *ngIf=\"view === 'month' || view === 'year'\">\n    <button mat-icon-button class=\"mat-calendar-previous-button\"\n      (click)=\"_previousClicked()\" [attr.disabled]=\"!_previousEnabled() ? '' : null\"\n      [attr.aria-label]=\"_prevButtonLabel\">\n    </button>\n\n    <button class=\"mat-calendar-heading-period mat-calendar-control mat-calendar-control-active\"\n    [@slideCalendar]=\"_animationDir\" (@slideCalendar.done)=\"_animationDir = ''\"\n    (click)=\"_currentPeriodClicked()\"\n    [attr.aria-label]=\"_periodButtonLabel\">\n      <strong>{{ _periodButtonText }}</strong>\n    </button>\n\n    <button mat-icon-button class=\"mat-calendar-next-button\"\n      (click)=\"_nextClicked()\" [attr.disabled]=\"!_nextEnabled() ? '' : null\"\n      [attr.aria-label]=\"_nextButtonLabel\">\n    </button>\n  </div>\n\n  <div class=\"mat-calendar-main\" [ngSwitch]=\"view\" cdkMonitorSubtreeFocus tabindex=\"-1\">\n\n    <mat-clock-view\n      *ngSwitchCase=\"'clock'\"\n      [(activeDate)]=\"activeDate\"\n      [selected]=\"selected\"\n      [dateFilter]=\"_dateFilterForViews\"\n      [clockStep]=\"clockStep\"\n      [twelveHour]=\"twelveHour\"\n      [hourView]=\"_hourView\"\n      (selectedTime)=\"_timeSelected($event)\"\n      (selectedChange)=\"_timeChanged($event)\"\n      (changeView)=\"_hourView = !_hourView\">\n    </mat-clock-view>\n\n    <mat-month-view\n      *ngSwitchCase=\"'month'\"\n      [(activeDate)]=\"activeDate\"\n      [selected]=\"selected\"\n      [dateFilter]=\"_dateFilterForViews\"\n      [maxDate]=\"maxDate\"\n      [minDate]=\"minDate\"\n      [animationDir]=\"_animationDir\"\n      (selectedChange)=\"_dateSelected($event)\"\n      (_userSelection)=\"_showHourView()\">\n    </mat-month-view>\n\n    <mat-year-view\n      *ngSwitchCase=\"'year'\"\n      [(activeDate)]=\"activeDate\"\n      [selected]=\"selected\"\n      [dateFilter]=\"_dateFilterForViews\"\n      [maxDate]=\"maxDate\"\n      [minDate]=\"minDate\"\n      [animationDir]=\"_animationDir\"\n      (selectedChange)=\"_monthSelected($event)\">\n    </mat-year-view>\n\n    <mat-years-view\n      *ngSwitchCase=\"'years'\"\n      [(activeDate)]=\"activeDate\"\n      [selected]=\"selected\"\n      [dateFilter]=\"_dateFilterForViews\"\n      [maxDate]=\"maxDate\"\n      [minDate]=\"minDate\"\n      (selectedChange)=\"_yearSelected($event)\">\n    </mat-years-view>\n  </div>\n\n  <div class=\"mat-calendar-footer\">\n    <button mat-button\n    (click)=\"_cancelClicked()\"\n    [attr.aria-label]=\"_intl.buttonCancelLabel\">\n      {{ _intl.buttonCancelText }}\n    </button>\n\n    <button mat-button\n    (click)=\"_submitClicked()\"\n    [attr.aria-label]=\"_intl.buttonSubmitLabel\">\n      {{ _intl.buttonSubmitText }}\n    </button>\n  </div>\n</div>\n",
                    // styleUrls: ['calendar.css'],
                    host: {
                        class: 'mat-calendar'
                    },
                    animations: [matDatepickerAnimations.controlActive, matDatepickerAnimations.slideCalendar],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false
                },] },
    ];
    MatCalendar.ctorParameters = function () { return [
        { type: MatDatepickerIntl },
        { type: DateAdapter, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_FORMATS,] }] },
        { type: ChangeDetectorRef }
    ]; };
    MatCalendar.propDecorators = {
        startAt: [{ type: Input }],
        type: [{ type: Input }],
        startView: [{ type: Input }],
        selected: [{ type: Input }],
        minDate: [{ type: Input }],
        maxDate: [{ type: Input }],
        dateFilter: [{ type: Input }],
        clockStep: [{ type: Input }],
        twelveHour: [{ type: Input }],
        selectedChange: [{ type: Output }],
        _userSelection: [{ type: Output }],
        clockView: [{ type: ViewChild, args: [MatClockView,] }],
        monthView: [{ type: ViewChild, args: [MatMonthView,] }],
        yearView: [{ type: ViewChild, args: [MatYearView,] }],
        yearsView: [{ type: ViewChild, args: [MatYearsView,] }]
    };
    return MatCalendar;
}());
export { MatCalendar };
if (false) {
    /** @type {?} */
    MatCalendar.prototype._intlChanges;
    /**
     * Used for scheduling that focus should be moved to the active cell on the next tick.
     * We need to schedule it, rather than do it immediately, because we have to wait
     * for Angular to re-evaluate the view children.
     * @type {?}
     */
    MatCalendar.prototype._moveFocusOnNextTick;
    /** @type {?} */
    MatCalendar.prototype._startAt;
    /**
     * The type of value handled by the calendar.
     * @type {?}
     */
    MatCalendar.prototype.type;
    /**
     * Which view the calendar should be started in.
     * @type {?}
     */
    MatCalendar.prototype.startView;
    /**
     * Current calendar view
     * @type {?}
     */
    MatCalendar.prototype.view;
    /** @type {?} */
    MatCalendar.prototype._selected;
    /** @type {?} */
    MatCalendar.prototype._minDate;
    /** @type {?} */
    MatCalendar.prototype._maxDate;
    /**
     * A function used to filter which dates are selectable.
     * @type {?}
     */
    MatCalendar.prototype.dateFilter;
    /**
     * Clock interval
     * @type {?}
     */
    MatCalendar.prototype.clockStep;
    /**
     * Clock hour format
     * @type {?}
     */
    MatCalendar.prototype.twelveHour;
    /**
     * Emits when the currently selected date changes.
     * @type {?}
     */
    MatCalendar.prototype.selectedChange;
    /**
     * Emits when any date is selected.
     * @type {?}
     */
    MatCalendar.prototype._userSelection;
    /**
     * Reference to the current clock view component.
     * @type {?}
     */
    MatCalendar.prototype.clockView;
    /**
     * Reference to the current month view component.
     * @type {?}
     */
    MatCalendar.prototype.monthView;
    /**
     * Reference to the current year view component.
     * @type {?}
     */
    MatCalendar.prototype.yearView;
    /**
     * Reference to the current years view component.
     * @type {?}
     */
    MatCalendar.prototype.yearsView;
    /**
     * Date filter for the month and year views.
     * @type {?}
     */
    MatCalendar.prototype._dateFilterForViews;
    /** @type {?} */
    MatCalendar.prototype._clampedActiveDate;
    /** @type {?} */
    MatCalendar.prototype._currentView;
    /**
     * Emits whenever there is a state change that the header may need to respond to.
     * @type {?}
     */
    MatCalendar.prototype.stateChanges;
    /**
     * Animations handler
     * @type {?}
     */
    MatCalendar.prototype._animationDir;
    /**
     * Whether the active date is AM or not
     * @type {?}
     */
    MatCalendar.prototype._isAm;
    /**
     * Whether the calendar process the time.
     * @type {?}
     */
    MatCalendar.prototype._hasTime;
    /**
     * Whether the calendar is in hour view.
     * @type {?}
     */
    MatCalendar.prototype._hourView;
    /**
     * The label for the calendar header buttons.
     * @type {?}
     */
    MatCalendar.prototype._yearButtonText;
    /** @type {?} */
    MatCalendar.prototype._dayButtonText;
    /** @type {?} */
    MatCalendar.prototype._monthdayButtonText;
    /** @type {?} */
    MatCalendar.prototype._hourButtonText;
    /** @type {?} */
    MatCalendar.prototype._minuteButtonText;
    /**
     * The label for the current calendar view.
     * @type {?}
     */
    MatCalendar.prototype._periodButtonText;
    /** @type {?} */
    MatCalendar.prototype._periodButtonLabel;
    /**
     * The label for the the previous button.
     * @type {?}
     */
    MatCalendar.prototype._prevButtonLabel;
    /**
     * The label for the the next button.
     * @type {?}
     */
    MatCalendar.prototype._nextButtonLabel;
    /** @type {?} */
    MatCalendar.prototype._intl;
    /** @type {?} */
    MatCalendar.prototype._dateAdapter;
    /** @type {?} */
    MatCalendar.prototype._dateFormats;
    /** @type {?} */
    MatCalendar.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY29hY2hjYXJlL2RhdGVwaWNrZXIvIiwic291cmNlcyI6WyJjYWxlbmRhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQVFBLE9BQU8sRUFHTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFHTCxRQUFRLEVBQ1IsTUFBTSxFQUVOLFNBQVMsRUFDVCxpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUM1QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQWtCLE1BQU0sY0FBYyxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDbEUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUM1QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxjQUFjLENBQUM7Ozs7OztBQWtCNUM7SUErVkUscUJBQ1MsS0FBd0IsRUFDWCxZQUE0QixFQUd4QyxZQUE0QixFQUM1QixrQkFBcUM7UUFOL0MsaUJBb0JDO1FBbkJRLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ1gsaUJBQVksR0FBWixZQUFZLENBQWdCO1FBR3hDLGlCQUFZLEdBQVosWUFBWSxDQUFnQjtRQUM1Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBeE0v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ZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdDaGVja2VkLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVmlld0NoaWxkLFxuICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTWF0Q2xvY2tWaWV3IH0gZnJvbSAnLi9jbG9jay12aWV3JztcbmltcG9ydCB7IE1BVF9EQVRFX0ZPUk1BVFMsIE1hdERhdGVGb3JtYXRzIH0gZnJvbSAnLi9jb3JlL2luZGV4JztcbmltcG9ydCB7IERhdGVBZGFwdGVyIH0gZnJvbSAnLi9jb3JlL2luZGV4JztcbmltcG9ydCB7IG1hdERhdGVwaWNrZXJBbmltYXRpb25zIH0gZnJvbSAnLi9kYXRlcGlja2VyLWFuaW1hdGlvbnMnO1xuaW1wb3J0IHsgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IgfSBmcm9tICcuL2RhdGVwaWNrZXItZXJyb3JzJztcbmltcG9ydCB7IE1hdERhdGVwaWNrZXJJbnRsIH0gZnJvbSAnLi9kYXRlcGlja2VyLWludGwnO1xuaW1wb3J0IHsgTWF0TW9udGhWaWV3IH0gZnJvbSAnLi9tb250aC12aWV3JztcbmltcG9ydCB7IE1hdFllYXJWaWV3IH0gZnJvbSAnLi95ZWFyLXZpZXcnO1xuaW1wb3J0IHsgTWF0WWVhcnNWaWV3IH0gZnJvbSAnLi95ZWFycy12aWV3JztcblxuLyoqXG4gKiBQb3NzaWJsZSB2aWV3cyBmb3IgdGhlIGNhbGVuZGFyLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgdHlwZSBNYXRDYWxlbmRhclZpZXcgPSAnY2xvY2snIHwgJ21vbnRoJyB8ICd5ZWFyJyB8ICd5ZWFycyc7XG5cbi8qKlxuICogUG9zc2libGUgcmV0dXJuIHR5cGVzLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgdHlwZSBNYXRDYWxlbmRhclR5cGUgPSAnZGF0ZScgfCAnZGF0ZXRpbWUnIHwgJ3RpbWUnO1xuXG4vKipcbiAqIEEgY2FsZW5kYXIgdGhhdCBpcyB1c2VkIGFzIHBhcnQgb2YgdGhlIGRhdGVwaWNrZXIuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21hdC1jYWxlbmRhcicsXG4gIHRlbXBsYXRlOiBgPGRpdiBbY2xhc3NdPVwiJ21hdC1jYWxlbmRhci1oZWFkZXIgbWF0LWNhbGVuZGFyLXR5cGUtJyArIHR5cGVcIj5cblxuICA8ZGl2IGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci1kYXRlXCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cIm1hdC1jYWxlbmRhci1oZWFkZXItZGF0ZS15ZWFyIG1hdC1jYWxlbmRhci1jb250cm9sXCJcbiAgICBbY2xhc3MubWF0LWNhbGVuZGFyLWNvbnRyb2wtYWN0aXZlXT1cInZpZXcgPT0gJ3llYXJzJ1wiXG4gICAgW0Bjb250cm9sQWN0aXZlXT1cInZpZXcgPT0gJ3llYXJzJyA/ICdhY3RpdmUnIDogJydcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuc3dpdGNoVG9ZZWFyVmlld0xhYmVsXCJcbiAgICAoY2xpY2spPVwiY2hhbmdlVmlldygneWVhcnMnKVwiPlxuICAgICAge3sgX3llYXJCdXR0b25UZXh0IH19XG4gICAgPC9idXR0b24+XG5cbiAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci1kYXRlLW1vbnRoIG1hdC1jYWxlbmRhci1jb250cm9sXCJcbiAgICBbY2xhc3MubWF0LWNhbGVuZGFyLWNvbnRyb2wtYWN0aXZlXT1cInZpZXcgPT0gJ21vbnRoJyB8fCB2aWV3ID09ICd5ZWFyJ1wiXG4gICAgW0Bjb250cm9sQWN0aXZlXT1cInZpZXcgPT0gJ21vbnRoJyB8fCB2aWV3ID09ICd5ZWFyJyA/ICdhY3RpdmUnIDogJydcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuc3dpdGNoVG9Nb250aFZpZXdMYWJlbFwiXG4gICAgKGNsaWNrKT1cImNoYW5nZVZpZXcoJ21vbnRoJylcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci1kYXRlLWRheW5hbWVcIj57eyBfZGF5QnV0dG9uVGV4dCB9fSwgPC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtYXQtY2FsZW5kYXItaGVhZGVyLWRhdGUtbW9udGhkYXlcIj57eyBfbW9udGhkYXlCdXR0b25UZXh0IH19PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRlci10aW1lXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1oZWFkZXItdGltZS1ob3VyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWNvbnRyb2xcIlxuICAgICAgW2NsYXNzLm1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZV09XCJ2aWV3ID09ICdjbG9jaycgJiYgX2hvdXJWaWV3XCJcbiAgICAgIFtAY29udHJvbEFjdGl2ZV09XCJ2aWV3ID09ICdjbG9jaycgJiYgX2hvdXJWaWV3ID8gJ2FjdGl2ZScgOiAnJ1wiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIl9pbnRsLnN3aXRjaFRvSG91clZpZXdMYWJlbFwiXG4gICAgICAoY2xpY2spPVwiX3Nob3dIb3VyVmlldygpXCI+XG4gICAgICAgIHt7IF9ob3VyQnV0dG9uVGV4dCB9fVxuICAgICAgPC9idXR0b24+XG4gICAgICA8c3Bhbj46PC9zcGFuPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cIm1hdC1jYWxlbmRhci1jb250cm9sXCJcbiAgICAgIFtjbGFzcy5tYXQtY2FsZW5kYXItY29udHJvbC1hY3RpdmVdPVwidmlldyA9PSAnY2xvY2snICYmICFfaG91clZpZXdcIlxuICAgICAgW0Bjb250cm9sQWN0aXZlXT1cInZpZXcgPT0gJ2Nsb2NrJyAmJiAhX2hvdXJWaWV3ID8gJ2FjdGl2ZScgOiAnJ1wiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIl9pbnRsLnN3aXRjaFRvTWludXRlVmlld0xhYmVsXCJcbiAgICAgIChjbGljayk9XCJfc2hvd01pbnV0ZVZpZXcoKVwiPlxuICAgICAgICB7eyBfbWludXRlQnV0dG9uVGV4dCB9fVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1oZWFkZXItdGltZS1hbXBtXCIgKm5nSWY9XCJ0d2VsdmVIb3VyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWNvbnRyb2xcIlxuICAgICAgW2NsYXNzLm1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZV09XCJfaXNBbVwiXG4gICAgICBbQGNvbnRyb2xBY3RpdmVdPVwiX2lzQW0gPyAnYWN0aXZlJyA6ICcnXCJcbiAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuc2V0VG9BTUxhYmVsXCJcbiAgICAgIChjbGljayk9XCJfdG9nZ2xlQW1QbSh0cnVlKVwiPlxuICAgICAgICBBTVxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWNvbnRyb2xcIlxuICAgICAgW2NsYXNzLm1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZV09XCIhX2lzQW1cIlxuICAgICAgW0Bjb250cm9sQWN0aXZlXT1cIiFfaXNBbSA/ICdhY3RpdmUnIDogJydcIlxuICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfaW50bC5zZXRUb1BNTGFiZWxcIlxuICAgICAgKGNsaWNrKT1cIl90b2dnbGVBbVBtKGZhbHNlKVwiPlxuICAgICAgICBQTVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgW2NsYXNzXT1cIidtYXQtY2FsZW5kYXItY29udGVudCBtYXQtY2FsZW5kYXItdmlldy0nICsgdmlld1wiPlxuXG4gIDxkaXYgY2xhc3M9XCJtYXQtY2FsZW5kYXItaGVhZGluZ1wiICpuZ0lmPVwidmlldyA9PT0gJ21vbnRoJyB8fCB2aWV3ID09PSAneWVhcidcIj5cbiAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiBjbGFzcz1cIm1hdC1jYWxlbmRhci1wcmV2aW91cy1idXR0b25cIlxuICAgICAgKGNsaWNrKT1cIl9wcmV2aW91c0NsaWNrZWQoKVwiIFthdHRyLmRpc2FibGVkXT1cIiFfcHJldmlvdXNFbmFibGVkKCkgPyAnJyA6IG51bGxcIlxuICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfcHJldkJ1dHRvbkxhYmVsXCI+XG4gICAgPC9idXR0b24+XG5cbiAgICA8YnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLWhlYWRpbmctcGVyaW9kIG1hdC1jYWxlbmRhci1jb250cm9sIG1hdC1jYWxlbmRhci1jb250cm9sLWFjdGl2ZVwiXG4gICAgW0BzbGlkZUNhbGVuZGFyXT1cIl9hbmltYXRpb25EaXJcIiAoQHNsaWRlQ2FsZW5kYXIuZG9uZSk9XCJfYW5pbWF0aW9uRGlyID0gJydcIlxuICAgIChjbGljayk9XCJfY3VycmVudFBlcmlvZENsaWNrZWQoKVwiXG4gICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfcGVyaW9kQnV0dG9uTGFiZWxcIj5cbiAgICAgIDxzdHJvbmc+e3sgX3BlcmlvZEJ1dHRvblRleHQgfX08L3N0cm9uZz5cbiAgICA8L2J1dHRvbj5cblxuICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIGNsYXNzPVwibWF0LWNhbGVuZGFyLW5leHQtYnV0dG9uXCJcbiAgICAgIChjbGljayk9XCJfbmV4dENsaWNrZWQoKVwiIFthdHRyLmRpc2FibGVkXT1cIiFfbmV4dEVuYWJsZWQoKSA/ICcnIDogbnVsbFwiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIl9uZXh0QnV0dG9uTGFiZWxcIj5cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1tYWluXCIgW25nU3dpdGNoXT1cInZpZXdcIiBjZGtNb25pdG9yU3VidHJlZUZvY3VzIHRhYmluZGV4PVwiLTFcIj5cblxuICAgIDxtYXQtY2xvY2stdmlld1xuICAgICAgKm5nU3dpdGNoQ2FzZT1cIidjbG9jaydcIlxuICAgICAgWyhhY3RpdmVEYXRlKV09XCJhY3RpdmVEYXRlXCJcbiAgICAgIFtzZWxlY3RlZF09XCJzZWxlY3RlZFwiXG4gICAgICBbZGF0ZUZpbHRlcl09XCJfZGF0ZUZpbHRlckZvclZpZXdzXCJcbiAgICAgIFtjbG9ja1N0ZXBdPVwiY2xvY2tTdGVwXCJcbiAgICAgIFt0d2VsdmVIb3VyXT1cInR3ZWx2ZUhvdXJcIlxuICAgICAgW2hvdXJWaWV3XT1cIl9ob3VyVmlld1wiXG4gICAgICAoc2VsZWN0ZWRUaW1lKT1cIl90aW1lU2VsZWN0ZWQoJGV2ZW50KVwiXG4gICAgICAoc2VsZWN0ZWRDaGFuZ2UpPVwiX3RpbWVDaGFuZ2VkKCRldmVudClcIlxuICAgICAgKGNoYW5nZVZpZXcpPVwiX2hvdXJWaWV3ID0gIV9ob3VyVmlld1wiPlxuICAgIDwvbWF0LWNsb2NrLXZpZXc+XG5cbiAgICA8bWF0LW1vbnRoLXZpZXdcbiAgICAgICpuZ1N3aXRjaENhc2U9XCInbW9udGgnXCJcbiAgICAgIFsoYWN0aXZlRGF0ZSldPVwiYWN0aXZlRGF0ZVwiXG4gICAgICBbc2VsZWN0ZWRdPVwic2VsZWN0ZWRcIlxuICAgICAgW2RhdGVGaWx0ZXJdPVwiX2RhdGVGaWx0ZXJGb3JWaWV3c1wiXG4gICAgICBbbWF4RGF0ZV09XCJtYXhEYXRlXCJcbiAgICAgIFttaW5EYXRlXT1cIm1pbkRhdGVcIlxuICAgICAgW2FuaW1hdGlvbkRpcl09XCJfYW5pbWF0aW9uRGlyXCJcbiAgICAgIChzZWxlY3RlZENoYW5nZSk9XCJfZGF0ZVNlbGVjdGVkKCRldmVudClcIlxuICAgICAgKF91c2VyU2VsZWN0aW9uKT1cIl9zaG93SG91clZpZXcoKVwiPlxuICAgIDwvbWF0LW1vbnRoLXZpZXc+XG5cbiAgICA8bWF0LXllYXItdmlld1xuICAgICAgKm5nU3dpdGNoQ2FzZT1cIid5ZWFyJ1wiXG4gICAgICBbKGFjdGl2ZURhdGUpXT1cImFjdGl2ZURhdGVcIlxuICAgICAgW3NlbGVjdGVkXT1cInNlbGVjdGVkXCJcbiAgICAgIFtkYXRlRmlsdGVyXT1cIl9kYXRlRmlsdGVyRm9yVmlld3NcIlxuICAgICAgW21heERhdGVdPVwibWF4RGF0ZVwiXG4gICAgICBbbWluRGF0ZV09XCJtaW5EYXRlXCJcbiAgICAgIFthbmltYXRpb25EaXJdPVwiX2FuaW1hdGlvbkRpclwiXG4gICAgICAoc2VsZWN0ZWRDaGFuZ2UpPVwiX21vbnRoU2VsZWN0ZWQoJGV2ZW50KVwiPlxuICAgIDwvbWF0LXllYXItdmlldz5cblxuICAgIDxtYXQteWVhcnMtdmlld1xuICAgICAgKm5nU3dpdGNoQ2FzZT1cIid5ZWFycydcIlxuICAgICAgWyhhY3RpdmVEYXRlKV09XCJhY3RpdmVEYXRlXCJcbiAgICAgIFtzZWxlY3RlZF09XCJzZWxlY3RlZFwiXG4gICAgICBbZGF0ZUZpbHRlcl09XCJfZGF0ZUZpbHRlckZvclZpZXdzXCJcbiAgICAgIFttYXhEYXRlXT1cIm1heERhdGVcIlxuICAgICAgW21pbkRhdGVdPVwibWluRGF0ZVwiXG4gICAgICAoc2VsZWN0ZWRDaGFuZ2UpPVwiX3llYXJTZWxlY3RlZCgkZXZlbnQpXCI+XG4gICAgPC9tYXQteWVhcnMtdmlldz5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cIm1hdC1jYWxlbmRhci1mb290ZXJcIj5cbiAgICA8YnV0dG9uIG1hdC1idXR0b25cbiAgICAoY2xpY2spPVwiX2NhbmNlbENsaWNrZWQoKVwiXG4gICAgW2F0dHIuYXJpYS1sYWJlbF09XCJfaW50bC5idXR0b25DYW5jZWxMYWJlbFwiPlxuICAgICAge3sgX2ludGwuYnV0dG9uQ2FuY2VsVGV4dCB9fVxuICAgIDwvYnV0dG9uPlxuXG4gICAgPGJ1dHRvbiBtYXQtYnV0dG9uXG4gICAgKGNsaWNrKT1cIl9zdWJtaXRDbGlja2VkKClcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiX2ludGwuYnV0dG9uU3VibWl0TGFiZWxcIj5cbiAgICAgIHt7IF9pbnRsLmJ1dHRvblN1Ym1pdFRleHQgfX1cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gIC8vIHN0eWxlVXJsczogWydjYWxlbmRhci5jc3MnXSxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnbWF0LWNhbGVuZGFyJ1xuICB9LFxuICBhbmltYXRpb25zOiBbbWF0RGF0ZXBpY2tlckFuaW1hdGlvbnMuY29udHJvbEFjdGl2ZSwgbWF0RGF0ZXBpY2tlckFuaW1hdGlvbnMuc2xpZGVDYWxlbmRhcl0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZVxufSlcbmV4cG9ydCBjbGFzcyBNYXRDYWxlbmRhcjxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0NoZWNrZWQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfaW50bENoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogVXNlZCBmb3Igc2NoZWR1bGluZyB0aGF0IGZvY3VzIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgYWN0aXZlIGNlbGwgb24gdGhlIG5leHQgdGljay5cbiAgICogV2UgbmVlZCB0byBzY2hlZHVsZSBpdCwgcmF0aGVyIHRoYW4gZG8gaXQgaW1tZWRpYXRlbHksIGJlY2F1c2Ugd2UgaGF2ZSB0byB3YWl0XG4gICAqIGZvciBBbmd1bGFyIHRvIHJlLWV2YWx1YXRlIHRoZSB2aWV3IGNoaWxkcmVuLlxuICAgKi9cbiAgcHJpdmF0ZSBfbW92ZUZvY3VzT25OZXh0VGljayA9IGZhbHNlO1xuXG4gIC8qKiBBIGRhdGUgcmVwcmVzZW50aW5nIHRoZSBwZXJpb2QgKG1vbnRoIG9yIHllYXIpIHRvIHN0YXJ0IHRoZSBjYWxlbmRhciBpbi4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHN0YXJ0QXQoKTogRCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9zdGFydEF0O1xuICB9XG4gIHNldCBzdGFydEF0KHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgfVxuICBwcml2YXRlIF9zdGFydEF0OiBEIHwgbnVsbDtcblxuICAvKiogVGhlIHR5cGUgb2YgdmFsdWUgaGFuZGxlZCBieSB0aGUgY2FsZW5kYXIuICovXG4gIEBJbnB1dCgpIHR5cGU6IE1hdENhbGVuZGFyVHlwZSA9ICdkYXRlJztcblxuICAvKiogV2hpY2ggdmlldyB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIHN0YXJ0ZWQgaW4uICovXG4gIEBJbnB1dCgpIHN0YXJ0VmlldzogTWF0Q2FsZW5kYXJWaWV3ID0gJ21vbnRoJztcblxuICAvKiogQ3VycmVudCBjYWxlbmRhciB2aWV3ICovXG4gIHZpZXc6IE1hdENhbGVuZGFyVmlldztcblxuICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgc2VsZWN0ZWQoKTogRCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgfVxuICBzZXQgc2VsZWN0ZWQodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgICBpZiAodGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX3NlbGVjdGVkO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9zZWxlY3RlZDogRCB8IG51bGw7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1pbkRhdGUoKTogRCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9taW5EYXRlO1xuICB9XG4gIHNldCBtaW5EYXRlKHZhbHVlOiBEIHwgbnVsbCkge1xuICAgIHRoaXMuX21pbkRhdGUgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcbiAgfVxuICBwcml2YXRlIF9taW5EYXRlOiBEIHwgbnVsbDtcblxuICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xuICBASW5wdXQoKVxuICBnZXQgbWF4RGF0ZSgpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX21heERhdGU7XG4gIH1cbiAgc2V0IG1heERhdGUodmFsdWU6IEQgfCBudWxsKSB7XG4gICAgdGhpcy5fbWF4RGF0ZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl9kYXRlQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICB9XG4gIHByaXZhdGUgX21heERhdGU6IEQgfCBudWxsO1xuXG4gIC8qKiBBIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGRhdGVzIGFyZSBzZWxlY3RhYmxlLiAqL1xuICBASW5wdXQoKSBkYXRlRmlsdGVyOiAoZGF0ZTogRCwgdW5pdD86IHN0cmluZykgPT4gYm9vbGVhbjtcblxuICAvKiogQ2xvY2sgaW50ZXJ2YWwgKi9cbiAgQElucHV0KCkgY2xvY2tTdGVwID0gMTtcblxuICAvKiogQ2xvY2sgaG91ciBmb3JtYXQgKi9cbiAgQElucHV0KCkgdHdlbHZlSG91ciA9IGZhbHNlO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZSBjaGFuZ2VzLiAqL1xuICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEQ+KCk7XG5cbiAgLyoqIEVtaXRzIHdoZW4gYW55IGRhdGUgaXMgc2VsZWN0ZWQuICovXG4gIEBPdXRwdXQoKSBfdXNlclNlbGVjdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGNsb2NrIHZpZXcgY29tcG9uZW50LiAqL1xuICBAVmlld0NoaWxkKE1hdENsb2NrVmlldykgY2xvY2tWaWV3OiBNYXRDbG9ja1ZpZXc8RD47XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBtb250aCB2aWV3IGNvbXBvbmVudC4gKi9cbiAgQFZpZXdDaGlsZChNYXRNb250aFZpZXcpIG1vbnRoVmlldzogTWF0TW9udGhWaWV3PEQ+O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgeWVhciB2aWV3IGNvbXBvbmVudC4gKi9cbiAgQFZpZXdDaGlsZChNYXRZZWFyVmlldykgeWVhclZpZXc6IE1hdFllYXJWaWV3PEQ+O1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgeWVhcnMgdmlldyBjb21wb25lbnQuICovXG4gIEBWaWV3Q2hpbGQoTWF0WWVhcnNWaWV3KSB5ZWFyc1ZpZXc6IE1hdFllYXJzVmlldzxEPjtcblxuICAvKiogRGF0ZSBmaWx0ZXIgZm9yIHRoZSBtb250aCBhbmQgeWVhciB2aWV3cy4gKi9cbiAgX2RhdGVGaWx0ZXJGb3JWaWV3cyA9IChkYXRlOiBELCB1bml0ID0gJ21pbnV0ZScpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgISFkYXRlICYmXG4gICAgICAoIXRoaXMuZGF0ZUZpbHRlciB8fCB0aGlzLmRhdGVGaWx0ZXIoZGF0ZSkpICYmXG4gICAgICAoIXRoaXMubWluRGF0ZSB8fCB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShkYXRlLCB0aGlzLm1pbkRhdGUsIHVuaXQpID49IDApICYmXG4gICAgICAoIXRoaXMubWF4RGF0ZSB8fCB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShkYXRlLCB0aGlzLm1heERhdGUsIHVuaXQpIDw9IDApXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYWN0aXZlIGRhdGUuIFRoaXMgZGV0ZXJtaW5lcyB3aGljaCB0aW1lIHBlcmlvZCBpcyBzaG93biBhbmQgd2hpY2ggZGF0ZSBpc1xuICAgKiBoaWdobGlnaHRlZCB3aGVuIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gICAqL1xuICBnZXQgYWN0aXZlRGF0ZSgpOiBEIHtcbiAgICByZXR1cm4gdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGU7XG4gIH1cbiAgc2V0IGFjdGl2ZURhdGUodmFsdWU6IEQpIHtcbiAgICBjb25zdCBvbGRBY3RpdmVEYXRlID0gdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGU7XG4gICAgdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5jbGFtcERhdGUodmFsdWUsIHRoaXMubWluRGF0ZSwgdGhpcy5tYXhEYXRlKTtcbiAgICB0aGlzLl9pc0FtID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0SG91cnModGhpcy5fY2xhbXBlZEFjdGl2ZURhdGUpIDwgMTI7XG5cbiAgICBjb25zdCB1bml0ID0gdGhpcy52aWV3ID09PSAneWVhcicgPyAneWVhcicgOiAnbW9udGgnO1xuICAgIGNvbnN0IGRpZmYgPSB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShvbGRBY3RpdmVEYXRlLCB0aGlzLl9jbGFtcGVkQWN0aXZlRGF0ZSwgdW5pdCk7XG4gICAgaWYgKGRpZmYpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkRpciA9IGRpZmYgPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGxhYmVsc1xuICAgIGNvbnN0IGRheSA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERheU9mV2Vlayh0aGlzLmFjdGl2ZURhdGUpO1xuICAgIGxldCBob3VycyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldEhvdXJzKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgaWYgKHRoaXMudHdlbHZlSG91cikge1xuICAgICAgaG91cnMgPSBob3VycyA9PT0gMCA/IDEyIDogaG91cnMgPiAxMiA/IGhvdXJzIC0gMTIgOiBob3VycztcbiAgICB9XG4gICAgY29uc3QgbWludXRlcyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1pbnV0ZXModGhpcy5hY3RpdmVEYXRlKTtcblxuICAgIHN3aXRjaCAodGhpcy52aWV3KSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChcbiAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUsXG4gICAgICAgICAgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5tb250aFllYXJMYWJlbFxuICAgICAgICApO1xuICAgIH1cbiAgICB0aGlzLl95ZWFyQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKS50b1N0cmluZygpO1xuICAgIHRoaXMuX21vbnRoZGF5QnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhEYXlMYWJlbFxuICAgICk7XG4gICAgdGhpcy5fZGF5QnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERheU9mV2Vla05hbWVzKCdzaG9ydCcpW2RheV07XG4gICAgdGhpcy5faG91ckJ1dHRvblRleHQgPSBob3Vycy50b1N0cmluZygpO1xuICAgIHRoaXMuX21pbnV0ZUJ1dHRvblRleHQgPSAoJzAwJyArIG1pbnV0ZXMpLnNsaWNlKC0yKTtcblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuICBwcml2YXRlIF9jbGFtcGVkQWN0aXZlRGF0ZTogRDtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgaXMgaW4gbW9udGggdmlldy4gKi9cbiAgZ2V0IGN1cnJlbnRWaWV3KCk6IE1hdENhbGVuZGFyVmlldyB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3O1xuICB9XG4gIHNldCBjdXJyZW50Vmlldyh2YWx1ZTogTWF0Q2FsZW5kYXJWaWV3KSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSB2YWx1ZTtcbiAgICB0aGlzLl9tb3ZlRm9jdXNPbk5leHRUaWNrID0gdHJ1ZTtcbiAgfVxuICBwcml2YXRlIF9jdXJyZW50VmlldzogTWF0Q2FsZW5kYXJWaWV3O1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGVyZSBpcyBhIHN0YXRlIGNoYW5nZSB0aGF0IHRoZSBoZWFkZXIgbWF5IG5lZWQgdG8gcmVzcG9uZCB0by5cbiAgICovXG4gIHN0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIEFuaW1hdGlvbnMgaGFuZGxlciAqL1xuICBfYW5pbWF0aW9uRGlyOiBzdHJpbmc7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGFjdGl2ZSBkYXRlIGlzIEFNIG9yIG5vdCAqL1xuICBfaXNBbTogYm9vbGVhbjtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgcHJvY2VzcyB0aGUgdGltZS4gKi9cbiAgX2hhc1RpbWU6IGJvb2xlYW47XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIGluIGhvdXIgdmlldy4gKi9cbiAgX2hvdXJWaWV3OiBib29sZWFuID0gdHJ1ZTtcblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgY2FsZW5kYXIgaGVhZGVyIGJ1dHRvbnMuICovXG4gIF95ZWFyQnV0dG9uVGV4dDogc3RyaW5nO1xuXG4gIF9kYXlCdXR0b25UZXh0OiBzdHJpbmc7XG5cbiAgX21vbnRoZGF5QnV0dG9uVGV4dDogc3RyaW5nO1xuXG4gIF9ob3VyQnV0dG9uVGV4dDogc3RyaW5nO1xuXG4gIF9taW51dGVCdXR0b25UZXh0OiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBsYWJlbCBmb3IgdGhlIGN1cnJlbnQgY2FsZW5kYXIgdmlldy4gKi9cbiAgX3BlcmlvZEJ1dHRvblRleHQ6IHN0cmluZztcblxuICBfcGVyaW9kQnV0dG9uTGFiZWw6IHN0cmluZztcblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgdGhlIHByZXZpb3VzIGJ1dHRvbi4gKi9cbiAgX3ByZXZCdXR0b25MYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBUaGUgbGFiZWwgZm9yIHRoZSB0aGUgbmV4dCBidXR0b24uICovXG4gIF9uZXh0QnV0dG9uTGFiZWw6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgX2ludGw6IE1hdERhdGVwaWNrZXJJbnRsLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxEPixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoTUFUX0RBVEVfRk9STUFUUylcbiAgICBwcml2YXRlIF9kYXRlRm9ybWF0czogTWF0RGF0ZUZvcm1hdHMsXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmXG4gICkge1xuICAgIGlmICghdGhpcy5fZGF0ZUFkYXB0ZXIpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdEYXRlQWRhcHRlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdNQVRfREFURV9GT1JNQVRTJyk7XG4gICAgfVxuXG4gICAgdGhpcy5faW50bENoYW5nZXMgPSBfaW50bC5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBfY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5zdGFydEF0IHx8IHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCk7XG5cbiAgICB0aGlzLmNoYW5nZVZpZXcodGhpcy5zdGFydFZpZXcsIGZhbHNlKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICBpZiAodGhpcy5fbW92ZUZvY3VzT25OZXh0VGljaykge1xuICAgICAgdGhpcy5fbW92ZUZvY3VzT25OZXh0VGljayA9IGZhbHNlO1xuICAgICAgdGhpcy5mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9pbnRsQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgdGhpcy5faGFzVGltZSA9IHRoaXMudHlwZS5pbmRleE9mKCd0aW1lJykgPj0gMDtcbiAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzLnNlbGVjdGVkIHx8IGNoYW5nZXMubWluRGF0ZSB8fCBjaGFuZ2VzLm1heERhdGUgfHwgY2hhbmdlcy5kYXRlRmlsdGVyO1xuXG4gICAgaWYgKGNoYW5nZSAmJiAhY2hhbmdlLmZpcnN0Q2hhbmdlKSB7XG4gICAgICBjb25zdCB2aWV3ID0gdGhpcy5fZ2V0Q3VycmVudFZpZXdDb21wb25lbnQoKTtcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gYGRldGVjdENoYW5nZXNgIG1hbnVhbGx5IGhlcmUsIGJlY2F1c2UgdGhlIGBtaW5EYXRlYCwgYG1heERhdGVgIGV0Yy4gYXJlXG4gICAgICAgIC8vIHBhc3NlZCBkb3duIHRvIHRoZSB2aWV3IHZpYSBkYXRhIGJpbmRpbmdzIHdoaWNoIHdvbid0IGJlIHVwLXRvLWRhdGUgd2hlbiB3ZSBjYWxsIGBfaW5pdGAuXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdmlldy5faW5pdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIGNoYW5nZVZpZXcodmlldywgZm9jdXMgPSB0cnVlKSB7XG4gICAgc3dpdGNoICh2aWV3KSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uVGV4dCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgIHRoaXMuX3BlcmlvZEJ1dHRvbkxhYmVsID0gdGhpcy5faW50bC5zd2l0Y2hUb1llYXJzVmlld0xhYmVsO1xuICAgICAgICB0aGlzLl9uZXh0QnV0dG9uTGFiZWwgPSB0aGlzLl9pbnRsLm5leHRZZWFyTGFiZWw7XG4gICAgICAgIHRoaXMuX3ByZXZCdXR0b25MYWJlbCA9IHRoaXMuX2ludGwucHJldlllYXJMYWJlbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIHRoaXMuX3BlcmlvZEJ1dHRvblRleHQgPSB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoXG4gICAgICAgICAgdGhpcy5hY3RpdmVEYXRlLFxuICAgICAgICAgIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyTGFiZWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fcGVyaW9kQnV0dG9uTGFiZWwgPSB0aGlzLl9pbnRsLnN3aXRjaFRvWWVhclZpZXdMYWJlbDtcbiAgICAgICAgdGhpcy5fbmV4dEJ1dHRvbkxhYmVsID0gdGhpcy5faW50bC5uZXh0TW9udGhMYWJlbDtcbiAgICAgICAgdGhpcy5fcHJldkJ1dHRvbkxhYmVsID0gdGhpcy5faW50bC5wcmV2TW9udGhMYWJlbDtcbiAgICB9XG5cbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5fbW92ZUZvY3VzT25OZXh0VGljayA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZm9jdXNBY3RpdmVDZWxsKCkge1xuICAgIHRoaXMuX2dldEN1cnJlbnRWaWV3Q29tcG9uZW50KCkuX2ZvY3VzQWN0aXZlQ2VsbCgpO1xuICB9XG5cbiAgX3N1Ym1pdENsaWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgdGhpcy5fdXNlclNlbGVjdGlvbi5lbWl0KCk7XG4gIH1cblxuICBfY2FuY2VsQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyU2VsZWN0aW9uLmVtaXQoKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIGRhdGUgc2VsZWN0aW9uIGluIHRoZSBjbG9jayB2aWV3LiAqL1xuICBfdGltZUNoYW5nZWQoZGF0ZTogRCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBkYXRlO1xuICB9XG5cbiAgX3RpbWVTZWxlY3RlZChkYXRlOiBEKTogdm9pZCB7XG4gICAgLy8gaWYgKHRoaXMuYXV0b09rICYmIHRoaXMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgLy8gICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoZGF0ZSk7XG4gICAgLy8gICB0aGlzLl91c2VyU2VsZWN0aW9uLmVtaXQoKTtcbiAgICAvLyB9XG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGU7XG4gIH1cblxuICAvKiogSGFuZGxlcyBkYXRlIHNlbGVjdGlvbiBpbiB0aGUgbW9udGggdmlldy4gKi9cbiAgX2RhdGVTZWxlY3RlZChkYXRlOiBEKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGU7XG4gICAgaWYgKHRoaXMuX2hhc1RpbWUpIHtcbiAgICAgIHRoaXMuY2hhbmdlVmlldygnY2xvY2snKTtcbiAgICB9XG4gIH1cblxuICAvKiogSGFuZGxlcyBtb250aCBzZWxlY3Rpb24gaW4gdGhlIHllYXIgdmlldy4gKi9cbiAgX21vbnRoU2VsZWN0ZWQobW9udGg6IEQpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGVkID0gbW9udGg7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KCdtb250aCcpO1xuICB9XG5cbiAgX3llYXJTZWxlY3RlZCh5ZWFyOiBEKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHllYXI7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KCd5ZWFyJyk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgcGVyaW9kIGxhYmVsLiAqL1xuICBfY3VycmVudFBlcmlvZENsaWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KHRoaXMudmlldyA9PT0gJ21vbnRoJyA/ICd5ZWFyJyA6ICd5ZWFycycpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgdXNlciBjbGlja3Mgb24gdGhlIHByZXZpb3VzIGJ1dHRvbi4gKi9cbiAgX3ByZXZpb3VzQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9uYXZDYWxlbmRhcigtMSk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgbmV4dCBidXR0b24uICovXG4gIF9uZXh0Q2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9uYXZDYWxlbmRhcigxKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHVzZXIgY2xpY2tzIG9uIHRoZSB0aW1lIGxhYmVscy4gKi9cbiAgX3Nob3dIb3VyVmlldygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faGFzVGltZSkge1xuICAgICAgdGhpcy5faG91clZpZXcgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFuZ2VWaWV3KCdjbG9jaycpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93TWludXRlVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl9ob3VyVmlldyA9IGZhbHNlO1xuICAgIHRoaXMuY2hhbmdlVmlldygnY2xvY2snKTtcbiAgfVxuXG4gIF90b2dnbGVBbVBtKGFtKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2lzQW0gIT09IGFtKSB7XG4gICAgICBjb25zdCBkYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJIb3Vycyh0aGlzLmFjdGl2ZURhdGUsIHRoaXMuX2lzQW0gPyAxMiA6IC0xMik7XG4gICAgICBpZiAodGhpcy5fZGF0ZUZpbHRlckZvclZpZXdzKGRhdGUsICdtaW51dGUnKSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcHJldmlvdXMgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBfcHJldmlvdXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5taW5EYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLm1pbkRhdGUgfHwgIXRoaXMuX2lzU2FtZVZpZXcodGhpcy5hY3RpdmVEYXRlLCB0aGlzLm1pbkRhdGUpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG5leHQgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBfbmV4dEVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLm1heERhdGUgfHwgIXRoaXMuX2lzU2FtZVZpZXcodGhpcy5hY3RpdmVEYXRlLCB0aGlzLm1heERhdGUpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgY2FsZW5kYXIgZGlmZnMuICovXG4gIF9uYXZDYWxlbmRhcihkaWZmKTogdm9pZCB7XG4gICAgc3dpdGNoICh0aGlzLnZpZXcpIHtcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuYWN0aXZlRGF0ZSwgZGlmZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLmFjdGl2ZURhdGUsIGRpZmYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nsb2NrJzpcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5faG91clZpZXdcbiAgICAgICAgICA/IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFySG91cnModGhpcy5hY3RpdmVEYXRlLCBkaWZmKVxuICAgICAgICAgIDogdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNaW51dGVzKHRoaXMuYWN0aXZlRGF0ZSwgZGlmZik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSB0d28gZGF0ZXMgcmVwcmVzZW50IHRoZSBzYW1lIHZpZXcgaW4gdGhlIGN1cnJlbnQgdmlldyBtb2RlIChtb250aCBvciB5ZWFyKS4gKi9cbiAgcHJpdmF0ZSBfaXNTYW1lVmlldyhkYXRlMTogRCwgZGF0ZTI6IEQpOiBib29sZWFuIHtcbiAgICBzd2l0Y2ggKHRoaXMudmlldykge1xuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKGRhdGUxKSA9PT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMik7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIGNvbnN0IG1vbnRoWWVhciA9IHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyTGFiZWw7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KGRhdGUxLCBtb250aFllYXIpID09PSB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZTIsIG1vbnRoWWVhcilcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgJ2Nsb2NrJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IGhvdXJNaW51dGUgPSB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LnRpbWVMYWJlbDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZTEsIGhvdXJNaW51dGUpID09PVxuICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChkYXRlMiwgaG91ck1pbnV0ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBUaGUgZ2l2ZW4gb2JqZWN0IGlmIGl0IGlzIGJvdGggYSBkYXRlIGluc3RhbmNlIGFuZCB2YWxpZCwgb3RoZXJ3aXNlIG51bGwuXG4gICAqL1xuICBwcml2YXRlIF9nZXRWYWxpZERhdGVPck51bGwob2JqOiBhbnkpOiBEIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyLmlzRGF0ZUluc3RhbmNlKG9iaikgJiYgdGhpcy5fZGF0ZUFkYXB0ZXIuaXNWYWxpZChvYmopID8gb2JqIDogbnVsbDtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudCBjYWxlbmRhciB2aWV3LiAqL1xuICBwcml2YXRlIF9nZXRDdXJyZW50Vmlld0NvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9ja1ZpZXcgfHwgdGhpcy5tb250aFZpZXcgfHwgdGhpcy55ZWFyVmlldyB8fCB0aGlzLnllYXJzVmlldztcbiAgfVxufVxuIl19